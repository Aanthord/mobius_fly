<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√∂bius Savanna v8.0 - Complete Fruit Fly Brain</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #game-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #legend {
            width: 400px;
            background: rgba(0, 0, 0, 0.95);
            color: #00ff00;
            padding: 12px;
            overflow-y: auto;
            border-right: 2px solid #00ff00;
            font-size: 10px;
        }
        #legend h3 {
            color: #00ffff;
            margin: 8px 0 4px 0;
            font-size: 12px;
            border-bottom: 1px solid #00ffff;
        }
        #legend .key {
            margin: 3px 0;
            line-height: 1.2;
        }
        #legend .stat {
            color: #ffff00;
            font-weight: bold;
        }
        .section {
            margin-bottom: 10px;
        }
        .warning {
            color: #ff6600;
            font-weight: bold;
        }
        .danger {
            color: #ff0000;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        .quantum {
            color: #00ffff;
            font-weight: bold;
        }
        .brain {
            color: #ff00ff;
            font-weight: bold;
            text-shadow: 0 0 3px #ff00ff;
        }
        .gpu {
            color: #00ff00;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
        }
        .plateau {
            color: #ffd700;
            font-weight: bold;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .discovery-list {
            max-height: 80px;
            overflow-y: auto;
            font-size: 9px;
            margin-top: 4px;
            padding: 4px;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #ffd700;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="legend">
            <h2 style="color: #ff6b6b; margin: 0 0 8px 0; font-size: 15px;">M√ñBIUS SAVANNA v8.0</h2>
            <div style="color: #888; font-size: 9px; margin-bottom: 10px;">
                <span class="brain">FRUIT FLY</span> | 
                <span class="gpu" id="gpu-status">GPU: READY</span> | 
                <span class="quantum">100K FIL</span>
            </div>
            
            <div class="section">
                <h3>CONTROLS</h3>
                <div class="key">‚Üë‚Üì‚Üê‚Üí Move</div>
                <div class="key"><b>SPACE</b> Pass turn</div>
                <div class="key"><b>A</b> Toggle AI</div>
                <div class="key"><b>E</b> Pickup DNA/Food</div>
                <div class="key"><b>M</b> Mate</div>
                <div class="key"><b>1-9</b> Select offspring</div>
            </div>

            <div class="section">
                <h3>DROSOPHILA BRAIN</h3>
                <div class="key" id="ai-status">Status: <span class="brain">THINKING</span></div>
                <div class="key">CX Ring: <span id="cx-heading" class="brain">0¬∞</span></div>
                <div class="key">MB Valence: <span id="mb-valence" class="stat">0.0</span></div>
                <div class="key">Dopamine: <span id="dopamine" class="stat">0.0</span></div>
                <div class="key">AL Active: <span id="al-active" class="stat">0</span></div>
                <div class="key">Action: <span id="ai-strategy" class="brain">--</span></div>
                <div class="key">Decisions: <span id="decisions" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>SCORE & PROGRESS</h3>
                <div class="key">Score: <span id="score-display" class="stat">0</span></div>
                <div class="key">High: <span id="high-score-display" class="stat">0</span></div>
                <div class="key">Gens: <span id="gens-reached" class="stat">0</span></div>
                <div class="key">Mates: <span id="total-mates" class="stat">0</span></div>
                <div class="key">Foods: <span id="total-foods" class="stat">0</span></div>
                <div class="key">DNA: <span id="total-dna" class="stat">0</span></div>
                <div class="key">Distance: <span id="total-distance" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>LIFECYCLE</h3>
                <div class="key">Stage: <span id="stage-display" class="stat">LARVA</span></div>
                <div class="key">Age: <span id="age-display" class="stat">0</span>/<span id="max-age-display">30</span></div>
                <div class="key">Gen: <span id="gen-display" class="stat">1</span></div>
                <div class="key">Energy: <span id="energy-display" class="stat">100</span>%</div>
                <div class="key" id="has-brood" style="display: none;"><span style="color:#ff69b4">Brood! Press 1-9</span></div>
            </div>

            <div class="section">
                <h3>GENOME</h3>
                <div class="key">Loci: <span id="loci-count" class="stat">4</span>/10</div>
                <div class="key">Instab: <span id="instability-display" class="stat">3</span></div>
            </div>

            <div class="section">
                <h3>TOPOLOGY</h3>
                <div class="key">Parity: <span id="parity-display" class="quantum">NORMAL</span></div>
                <div class="key">Seams: <span id="seam-count" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>PLATEAU MUSEUM</h3>
                <div class="key">Discovered: <span id="plateau-count" class="plateau">0</span></div>
                <div id="plateau-list" class="discovery-list"></div>
            </div>

            <div class="section">
                <h3>NEARBY</h3>
                <div class="key">NPCs: <span id="npc-count" class="stat">0</span></div>
                <div class="key">Food: <span id="food-count" class="stat">0</span></div>
                <div class="key">Predators: <span id="pred-count" class="danger">0</span></div>
            </div>

            <div class="section">
                <h3>SPATIAL MEMORY</h3>
                <div class="key">Danger: <span id="mem-danger" class="stat">0</span></div>
                <div class="key">Visited: <span id="mem-visited" class="stat">0</span></div>
                <div class="key">Boundaries: <span id="mem-boundaries" class="stat">0</span></div>
            </div>
        </div>
        <div id="phaser-canvas"></div>
    </div>
    
    <script>
        // ============================================================================
        // GPU-ACCELERATED FIL MANIFOLD - 100K CELLS
        // ============================================================================
        
        class GPUFILManifold {
            constructor(n) {
                this.n = n;
                this.canvas = document.createElement('canvas');
                this.gl = this.canvas.getContext('webgl2');
                
                if (!this.gl) {
                    console.warn('WebGL2 not available, falling back to CPU');
                    this.useCPU = true;
                    this.state = new Float32Array(n * 4);
                    this._initialize_golden();
                    return;
                }
                
                const ext = this.gl.getExtension('EXT_color_buffer_float');
                if (!ext) {
                    console.warn('EXT_color_buffer_float not available, falling back to CPU');
                    this.useCPU = true;
                    this.state = new Float32Array(n * 4);
                    this._initialize_golden();
                    return;
                }
                
                this.useCPU = false;
                this.textureSize = Math.ceil(Math.sqrt(n));
                
                this.stateTexture = this.createTexture();
                this.outputTexture = this.createTexture();
                this.framebuffer = this.gl.createFramebuffer();
                this.program = this.createShaderProgram();
                
                if (!this.program) {
                    console.warn('Shader compilation failed, falling back to CPU');
                    this.useCPU = true;
                    this.state = new Float32Array(n * 4);
                    this._initialize_golden();
                    return;
                }
                
                this.state = new Float32Array(n * 4);
                this._initialize_golden();
                this.uploadState();
            }
            
            createTexture() {
                const gl = this.gl;
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize, this.textureSize, 
                             0, gl.RGBA, gl.FLOAT, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                return texture;
            }
            
            createShaderProgram() {
                const gl = this.gl;
                
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `#version 300 es
                    in vec2 position;
                    out vec2 texCoord;
                    void main() {
                        texCoord = position * 0.5 + 0.5;
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `);
                gl.compileShader(vertexShader);
                
                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                    console.error('Vertex shader compile error:', gl.getShaderInfoLog(vertexShader));
                    return null;
                }
                
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, `#version 300 es
                    precision highp float;
                    in vec2 texCoord;
                    out vec4 outColor;
                    uniform sampler2D stateTexture;
                    
                    void main() {
                        vec4 state = texture(stateTexture, texCoord);
                        float p = state.x;
                        float q = state.y;
                        
                        // Hamiltonian evolution
                        float dp = -sin(q) * 0.05 - p * 0.02;
                        float dq = cos(p) * 0.05 - q * 0.02;
                        
                        p += dp;
                        q += dq;
                        
                        // Decay
                        p *= 0.98;
                        q *= 0.98;
                        
                        outColor = vec4(p, q, state.z, state.w);
                    }
                `);
                gl.compileShader(fragmentShader);
                
                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                    console.error('Fragment shader compile error:', gl.getShaderInfoLog(fragmentShader));
                    return null;
                }
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Shader program link error:', gl.getProgramInfoLog(program));
                    return null;
                }
                
                return program;
            }
            
            _initialize_golden() {
                const phi = (1 + Math.sqrt(5)) / 2;
                const phi0 = 2 * Math.PI / phi;
                for (let i = 0; i < this.n; i++) {
                    this.state[i * 4] = Math.sin(phi0 * (i + 1)) * 0.1;
                    this.state[i * 4 + 1] = Math.cos(phi0 * (i + 1)) * 0.1;
                    this.state[i * 4 + 2] = 1.0;
                    this.state[i * 4 + 3] = 0.0;
                }
            }
            
            uploadState() {
                if (this.useCPU) return;
                const gl = this.gl;
                gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize, this.textureSize,
                             0, gl.RGBA, gl.FLOAT, this.state);
            }
            
            evolve() {
                if (this.useCPU) {
                    for (let i = 0; i < this.n; i++) {
                        const p = this.state[i * 4];
                        const q = this.state[i * 4 + 1];
                        const dp = -Math.sin(q) * 0.05 - p * 0.02;
                        const dq = Math.cos(p) * 0.05 - q * 0.02;
                        this.state[i * 4] = (p + dp) * 0.98;
                        this.state[i * 4 + 1] = (q + dq) * 0.98;
                    }
                    return;
                }
                
                const gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
                                       gl.TEXTURE_2D, this.outputTexture, 0);
                
                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                    console.error('Framebuffer incomplete, status:', status);
                    this.useCPU = true;
                    return;
                }
                
                gl.viewport(0, 0, this.textureSize, this.textureSize);
                gl.useProgram(this.program);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
                gl.uniform1i(gl.getUniformLocation(this.program, 'stateTexture'), 0);
                
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    -1, -1,  1, -1,  -1, 1,  1, 1
                ]), gl.STATIC_DRAW);
                
                const posLoc = gl.getAttribLocation(this.program, 'position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                [this.stateTexture, this.outputTexture] = [this.outputTexture, this.stateTexture];
            }
            
            downloadState() {
                if (this.useCPU) return;
                const gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                                       gl.TEXTURE_2D, this.stateTexture, 0);
                gl.readPixels(0, 0, this.textureSize, this.textureSize, gl.RGBA, gl.FLOAT, this.state);
            }
        }
        
        // ============================================================================
        // PLATEAU MUSEUM - Genome Stability Tracking
        // ============================================================================
        
        class PlateauMuseum {
            constructor() {
                this.plateaus = new Map(); // signature -> {genome, stability, discovered}
                this.count = 0;
            }
            
            checkAndSave(genome) {
                const loci = Object.keys(genome.slots).filter(k => genome.slots[k]);
                const stability = this.calculateStability(genome);
                
                if (stability < 60) return null; // Not stable enough
                
                const signature = loci.sort().join('-');
                if (this.plateaus.has(signature)) return null; // Already discovered
                
                const plateau = {
                    genome: JSON.parse(JSON.stringify(genome)),
                    loci: loci,
                    stability: stability,
                    discovered: Date.now(),
                    name: this.generateName(loci)
                };
                
                this.plateaus.set(signature, plateau);
                this.count++;
                
                console.log(`‚òÖ PLATEAU DISCOVERED: ${plateau.name} (stability: ${stability})`);
                return plateau;
            }
            
            calculateStability(genome) {
                const loci = Object.keys(genome.slots).filter(k => genome.slots[k]).length;
                const instability = genome.instability || 0;
                return Math.max(0, 100 - instability * 10 + loci * 5);
            }
            
            generateName(loci) {
                const prefixes = ['Neo', 'Proto', 'Hyper', 'Ultra', 'Meta', 'Super'];
                const suffixes = ['morph', 'type', 'form', 'variant', 'strain'];
                const prefix = prefixes[loci.length % prefixes.length];
                const suffix = suffixes[Math.floor(loci.length / 2) % suffixes.length];
                return `${prefix}-${loci.length}${suffix[0].toUpperCase()}`;
            }
            
            getRecent(n = 5) {
                return Array.from(this.plateaus.values())
                    .sort((a, b) => b.discovered - a.discovered)
                    .slice(0, n);
            }
        }
        
        // ============================================================================
        // FRUIT FLY CIRCUIT MODULES
        // ============================================================================
        
        // CX Ring Attractor - Heading stabilization
        class CXRing {
            constructor(M = 256) {
                this.M = M;
                this.r = new Float32Array(M);
                this.K = 4; // kernel width
                
                // Mexican hat weights
                this.W = {
                    center: 0.5,
                    exc: new Float32Array(this.K + 1),
                    inh: new Float32Array(this.K + 1)
                };
                
                // Excitatory: drops off with distance
                for (let k = 1; k <= this.K; k++) {
                    this.W.exc[k] = 0.3 * Math.exp(-k * k / 4.0);
                    this.W.inh[k] = -0.15 * Math.exp(-k * k / 8.0);
                }
                
                this.wrapInh = 2; // Broader inhibition
            }
            
            step(inputBump, gain = 1.0) {
                const out = new Float32Array(this.M);
                
                for (let i = 0; i < this.M; i++) {
                    let s = this.W.center * this.r[i];
                    
                    // Local excitation + broader inhibition
                    for (let k = 1; k <= this.K; k++) {
                        const il = (i - k + this.M) % this.M;
                        const ir = (i + k) % this.M;
                        s += this.W.exc[k] * (this.r[il] + this.r[ir]);
                        
                        const iInhL = (i - k * this.wrapInh + this.M) % this.M;
                        const iInhR = (i + k * this.wrapInh) % this.M;
                        s += this.W.inh[k] * (this.r[iInhL] + this.r[iInhR]);
                    }
                    
                    // Integrate with input
                    out[i] = Math.max(0, 0.92 * this.r[i] + 0.08 * (s + gain * inputBump[i]));
                }
                
                this.r.set(out);
            }
            
            getHeading() {
                // Find bump peak
                let maxIdx = 0;
                let maxVal = this.r[0];
                for (let i = 1; i < this.M; i++) {
                    if (this.r[i] > maxVal) {
                        maxVal = this.r[i];
                        maxIdx = i;
                    }
                }
                return maxIdx;
            }
            
            getHeadingAngle() {
                return (this.getHeading() / this.M) * 360;
            }
        }
        
        // Mushroom Body - Sparse coding + dopamine learning
        class MushroomBody {
            constructor(nKC = 2000, nMBON = 12) {
                this.nKC = nKC;
                this.nMBON = nMBON;
                
                // Kenyon cells (sparse activations)
                this.KC = new Float32Array(nKC);
                this.KCthresh = 0.5; // Sparsity threshold
                
                // Mushroom body output neurons
                this.MBON = new Float32Array(nMBON);
                
                // KC‚ÜíMBON weights (plastic)
                this.Wkm = new Float32Array(nKC * nMBON);
                
                // Initialize small random weights
                for (let i = 0; i < this.Wkm.length; i++) {
                    this.Wkm[i] = (Math.random() - 0.5) * 0.1;
                }
                
                // Learning rates
                this.lrPos = 0.002;
                this.lrNeg = 0.002;
                this.decay = 0.9995;
            }
            
            forward() {
                // KC ‚Üí MBON
                this.MBON.fill(0);
                for (let k = 0; k < this.nKC; k++) {
                    if (this.KC[k] > this.KCthresh) {
                        for (let m = 0; m < this.nMBON; m++) {
                            this.MBON[m] += this.KC[k] * this.Wkm[k * this.nMBON + m];
                        }
                    }
                }
                
                // Rectify MBON
                for (let m = 0; m < this.nMBON; m++) {
                    this.MBON[m] = Math.max(0, Math.min(1, this.MBON[m]));
                }
            }
            
            learn(dopamine) {
                const lr = dopamine > 0 ? this.lrPos : this.lrNeg;
                const sign = dopamine > 0 ? 1 : -1;
                
                // Hebbian/anti-Hebbian on active synapses
                for (let k = 0; k < this.nKC; k++) {
                    if (this.KC[k] > this.KCthresh) {
                        for (let m = 0; m < this.nMBON; m++) {
                            const idx = k * this.nMBON + m;
                            this.Wkm[idx] += sign * lr * this.KC[k] * this.MBON[m] * Math.abs(dopamine);
                            
                            // Decay + clamp
                            this.Wkm[idx] *= this.decay;
                            this.Wkm[idx] = Math.max(-0.5, Math.min(0.5, this.Wkm[idx]));
                        }
                    }
                }
            }
            
            getValence() {
                // MBON channels: 0-5 approach, 6-11 avoid
                let approach = 0;
                let avoid = 0;
                for (let i = 0; i < 6; i++) approach += this.MBON[i];
                for (let i = 6; i < 12; i++) avoid += this.MBON[i];
                return { approach: approach / 6, avoid: avoid / 6 };
            }
            
            getActiveKC() {
                let count = 0;
                for (let k = 0; k < this.nKC; k++) {
                    if (this.KC[k] > this.KCthresh) count++;
                }
                return count;
            }
        }
        
        // Antennal Lobe - Lateral inhibition for odor contrast
        class AntennalLobe {
            constructor(nGlom = 60) {
                this.nGlom = nGlom;
                this.r = new Float32Array(nGlom);
                this.W = new Float32Array(nGlom).fill(1.0); // Odor‚Üíglom (diagonal)
                this.gInh = 0.3; // Global inhibition strength
            }
            
            step(odorIn) {
                const mean = this.r.reduce((a, b) => a + b, 0) / this.nGlom;
                
                for (let i = 0; i < this.nGlom; i++) {
                    const drive = this.W[i] * (odorIn[i] || 0);
                    this.r[i] = Math.max(0, 0.9 * this.r[i] + 0.1 * (drive - this.gInh * mean));
                }
            }
            
            projectToKC(mb) {
                // Random sparse PN‚ÜíKC (10% active)
                for (let k = 0; k < mb.nKC; k++) {
                    let sum = 0;
                    // Sample 6 random glomeruli per KC
                    for (let s = 0; s < 6; s++) {
                        const g = Math.floor(Math.random() * this.nGlom);
                        sum += this.r[g];
                    }
                    mb.KC[k] = Math.tanh(sum / 6);
                }
            }
            
            getActiveGlomeruli() {
                let count = 0;
                for (let i = 0; i < this.nGlom; i++) {
                    if (this.r[i] > 0.1) count++;
                }
                return count;
            }
        }
        
        // LAL Action Selection - Winner-take-all gating
        class LALGate {
            constructor() {
                this.ch = new Float32Array(4); // UP, RIGHT, DOWN, LEFT
            }
            
            step(cxHeading, mbValence, drives) {
                // Convert heading to cardinal bias
                const steer = this.headingToCardinal(cxHeading, 256);
                
                // Drive modulation
                const foodBias = drives.hunger * mbValence.approach * 2.0;
                const mateBias = drives.mating * 1.5;
                const avoidBias = -mbValence.avoid * 3.0;
                
                // Update channels
                for (let i = 0; i < 4; i++) {
                    this.ch[i] = Math.max(0, 
                        0.85 * this.ch[i] + 
                        0.15 * (steer[i] + foodBias + mateBias + avoidBias)
                    );
                }
                
                // Winner-take-all
                let maxIdx = 0;
                let maxVal = this.ch[0];
                for (let i = 1; i < 4; i++) {
                    if (this.ch[i] > maxVal) {
                        maxVal = this.ch[i];
                        maxIdx = i;
                    }
                }
                
                return ['UP', 'RIGHT', 'DOWN', 'LEFT'][maxIdx];
            }
            
            headingToCardinal(k, M) {
                const angle = (k / M) * 2 * Math.PI;
                const axes = [Math.PI / 2, 0, 3 * Math.PI / 2, Math.PI]; // UP, RIGHT, DOWN, LEFT
                const out = new Float32Array(4);
                
                for (let i = 0; i < 4; i++) {
                    const d = Math.abs(Math.atan2(Math.sin(angle - axes[i]), Math.cos(angle - axes[i])));
                    out[i] = Math.max(0, 1 - d / (Math.PI / 2));
                }
                
                return out;
            }
        }
        
        // ============================================================================
        // FRUIT FLY AGENT
        // ============================================================================
        
        class FruitFlyAgent {
            constructor() {
                this.active = true;
                this.decisions = 0;
                this.tick = 0;
                this.currentStrategy = 'EXPLORE';
                
                // FIL manifold for dynamics
                this.brain = new GPUFILManifold(100000);
                
                // Fly circuit modules
                this.cx = new CXRing(256);
                this.mb = new MushroomBody(2000, 12);
                this.al = new AntennalLobe(60);
                this.lal = new LALGate();
                
                // Plateau museum
                this.museum = new PlateauMuseum();
                
                // Sensory bands
                this.BANDS = {
                    DIR_START: 0,
                    DIR_LEN: 2048,
                    CHEM_START: 2560,
                    CHEM_LEN: 512,
                    INT_START: 3584
                };
                
                // Learning state
                this._prevR = 0;
                this.dopamine = 0;
                
                // Spatial memory
                this.dangerMap = new Map();
                this.visitedTiles = new Map();
                this.boundaryMemory = new Map();
                this.boundaryLoopBreaker = 0;
                this.recentWraps = [];
                
                // Scoring
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('mobius_high_score') || '0');
                this.totalMates = 0;
                this.totalFood = 0;
                this.totalDNA = 0;
                this.generationsReached = 0;
                this.longestLife = 0;
                this.totalDistance = 0;
                this.achievementsUnlocked = new Set();
                
                console.log('ü™∞ Fruit Fly Brain initialized!', this.brain.useCPU ? 'CPU' : 'GPU');
                document.getElementById('gpu-status').textContent = this.brain.useCPU ? 'CPU: FALLBACK' : 'GPU: READY';
            }
            
            toggle() {
                this.active = !this.active;
                return this.active;
            }
            
            // Helper: Convert directional sensory band to bump for CX
            dirBandToBump(sens) {
                const bump = new Float32Array(256);
                const {DIR_START, DIR_LEN} = this.BANDS;
                
                for (let i = 0; i < DIR_LEN; i++) {
                    const a = Math.floor((i / DIR_LEN) * 256);
                    bump[a] += Math.max(0, sens[DIR_START + i]);
                }
                
                // Normalize
                const sum = bump.reduce((x, y) => x + y, 0) || 1;
                for (let i = 0; i < 256; i++) bump[i] /= sum;
                
                return bump;
            }
            
            // Compute dopamine from reward delta
            computeDopamine(reward) {
                const delta = reward - this._prevR;
                this._prevR = reward;
                this.dopamine = Math.max(-1, Math.min(1, delta / 100));
                return this.dopamine;
            }
            
            // Spatial memory management
            updateSpatialMemory(game) {
                // Decay old danger
                for (const [key, mem] of this.dangerMap.entries()) {
                    mem.age++;
                    mem.threat *= 0.95;
                    if (mem.threat < 0.1 || mem.age > 50) {
                        this.dangerMap.delete(key);
                    }
                }
                
                // Record predators
                game.predators.forEach(pred => {
                    const key = `${pred.q},${pred.r}`;
                    const threat = pred.speed === 0 ? 10.0 : (pred.speed * 5.0);
                    this.dangerMap.set(key, { threat, age: 0, type: pred.type });
                    
                    // Mark web zones
                    if (pred.speed === 0) {
                        for (let dq = -2; dq <= 2; dq++) {
                            for (let dr = -2; dr <= 2; dr++) {
                                if (dq === 0 && dr === 0) continue;
                                const adjKey = `${pred.q + dq},${pred.r + dr}`;
                                const adjThreat = 5.0 / (Math.abs(dq) + Math.abs(dr));
                                if (!this.dangerMap.has(adjKey) || this.dangerMap.get(adjKey).threat < adjThreat) {
                                    this.dangerMap.set(adjKey, { threat: adjThreat, age: 0, type: 'web_zone' });
                                }
                            }
                        }
                    }
                });
                
                // Track visited
                const currentKey = `${game.player.q},${game.player.r}`;
                if (this.visitedTiles.has(currentKey)) {
                    const visit = this.visitedTiles.get(currentKey);
                    visit.count++;
                    visit.lastVisit = this.tick;
                } else {
                    this.visitedTiles.set(currentKey, { count: 1, lastVisit: this.tick });
                }
                
                // Limit memory size
                if (this.visitedTiles.size > 200) {
                    const sorted = Array.from(this.visitedTiles.entries())
                        .sort((a, b) => a[1].lastVisit - b[1].lastVisit);
                    for (let i = 0; i < 50; i++) {
                        this.visitedTiles.delete(sorted[i][0]);
                    }
                }
            }
            
            cleanBoundaryMemory() {
                for (const [key, tickStored] of this.boundaryMemory.entries()) {
                    if (this.tick - tickStored > 30) {
                        this.boundaryMemory.delete(key);
                    }
                }
            }
            
            chooseSafeDirection(game, targetDq, targetDr) {
                const preferredDir = Math.abs(targetDq) > Math.abs(targetDr) ?
                    (targetDq > 0 ? 'RIGHT' : 'LEFT') :
                    (targetDr > 0 ? 'DOWN' : 'UP');
                
                const moves = {
                    'RIGHT': { q: 1, r: 0 },
                    'LEFT': { q: -1, r: 0 },
                    'DOWN': { q: 0, r: 1 },
                    'UP': { q: 0, r: -1 }
                };
                
                const dirScores = {};
                for (const [dir, delta] of Object.entries(moves)) {
                    const newQ = game.player.q + delta.q;
                    const newR = game.player.r + delta.r;
                    const key = `${newQ},${newR}`;
                    
                    let score = 1.0;
                    
                    if (this.dangerMap.has(key)) {
                        score -= this.dangerMap.get(key).threat;
                    }
                    
                    if (dir === preferredDir) {
                        score += 2.0;
                    }
                    
                    if (this.visitedTiles.has(key)) {
                        score -= this.visitedTiles.get(key).count * 0.1;
                    }
                    
                    dirScores[dir] = score;
                }
                
                const best = Object.entries(dirScores).reduce((a, b) => a[1] > b[1] ? a : b);
                
                // Log detour if taking safer route
                const straightDir = Math.abs(targetDq) > Math.abs(targetDr) ?
                    (targetDq > 0 ? 'RIGHT' : 'LEFT') :
                    (targetDr > 0 ? 'DOWN' : 'UP');
                if (best[0] !== straightDir && this.tick % 10 === 0) {
                    console.log(`[avoiding danger: ${straightDir}‚Üí${best[0]}]`);
                }
                
                return best[0];
            }
            
            exploreWithMemory(game) {
                this.cleanBoundaryMemory();
                
                if (this.boundaryLoopBreaker && this.boundaryLoopBreaker > 0) {
                    this.boundaryLoopBreaker--;
                    const lateralMoves = ['RIGHT', 'LEFT'];
                    const dir = lateralMoves[Math.floor(Math.random() * lateralMoves.length)];
                    console.log(`Breaking boundary loop: forcing ${dir}`);
                    return dir;
                }
                
                const moves = {
                    'RIGHT': { q: 1, r: 0 },
                    'LEFT': { q: -1, r: 0 },
                    'DOWN': { q: 0, r: 1 },
                    'UP': { q: 0, r: -1 }
                };
                
                const dirScores = {};
                for (const [dir, delta] of Object.entries(moves)) {
                    const newQ = game.player.q + delta.q;
                    const newR = game.player.r + delta.r;
                    const key = `${newQ},${newR}`;
                    
                    let score = 2.0;
                    
                    if (this.dangerMap.has(key)) {
                        score -= this.dangerMap.get(key).threat * 1.5;
                    }
                    
                    if (this.visitedTiles.has(key)) {
                        const visit = this.visitedTiles.get(key);
                        const recency = Math.max(0, 1.0 - (this.tick - visit.lastVisit) / 50);
                        score -= (visit.count * 0.5 + recency * 2.0);
                    } else {
                        score += 3.0;
                    }
                    
                    if (this.boundaryMemory.has(key)) {
                        const boundaryAge = this.tick - this.boundaryMemory.get(key);
                        const penalty = Math.max(0, 5.0 - boundaryAge * 0.15);
                        score -= penalty;
                    }
                    
                    if (newQ <= -15 || newQ >= 15 || newR <= -10 || newR >= 10) {
                        score -= 2.0;
                    }
                    
                    dirScores[dir] = score;
                }
                
                const sorted = Object.entries(dirScores).sort((a, b) => b[1] - a[1]);
                
                if (sorted.length >= 2 && Math.random() < 0.2) {
                    return sorted[1][0];
                }
                
                return sorted[0][0];
            }
            
            // Main decision loop - Fruit Fly circuits!
            decide(game) {
                if (!this.active) return null;
                this.decisions++;
                this.tick++;
                
                this.updateSpatialMemory(game);
                
                if (this.tick % 50 === 0) {
                    console.log(`üß† BRAIN: CX=${this.cx.getHeadingAngle().toFixed(0)}¬∞, DA=${this.dopamine.toFixed(2)}, KC=${this.mb.getActiveKC()}, Danger=${this.dangerMap.size}`);
                }
                
                // Encode sensory
                const sensory = this.encodeSensory(game);
                
                // Check for urgent actions
                if (game.brood) {
                    this.currentStrategy = 'SELECT';
                    console.log('SELECTING OFFSPRING!');
                    return { type: 'SELECT_OFFSPRING', index: 0 };
                }
                
                // Feed if standing on food
                const onFood = game.foodSources.some(f => f.q === game.player.q && f.r === game.player.r && f.respawnTimer === 0);
                if (onFood) {
                    this.currentStrategy = 'FEED';
                    console.log('FEEDING!');
                    return { type: 'FEED' };
                }
                
                // Mate if next to partner
                if (game.player.stage === 'ADULT' && !game.brood) {
                    const nearMate = game.npcFlies.find(n => Math.abs(n.q - game.player.q) + Math.abs(n.r - game.player.r) <= 2);
                    if (nearMate) {
                        this.currentStrategy = 'MATE';
                        console.log('MATING!');
                        return { type: 'MATE' };
                    }
                }
                
                // FRUIT FLY CIRCUIT PROCESSING
                
                // 1. Antennal Lobe - odor processing
                const odor = sensory.slice(this.BANDS.CHEM_START, this.BANDS.CHEM_START + this.BANDS.CHEM_LEN);
                this.al.step(odor);
                
                // 2. AL ‚Üí MB (sparse KC coding)
                this.al.projectToKC(this.mb);
                
                // 3. MB forward + learning
                this.mb.forward();
                const reward = this.computeReward(game);
                const dopamine = this.computeDopamine(reward);
                if (Math.abs(dopamine) > 0.01) {
                    this.mb.learn(dopamine);
                }
                
                // 4. CX ring attractor - heading from optic flow
                const flowBump = this.dirBandToBump(sensory);
                this.cx.step(flowBump, 1.0);
                
                // 5. LAL action selection
                const mbValence = this.mb.getValence();
                const drives = {
                    hunger: Math.min(1.0, sensory[this.BANDS.INT_START + 8] / 12.0),
                    mating: (game.player.stage === 'ADULT' && !game.brood) ? 1.0 : 0.0
                };
                
                // Threat override - flee if in immediate danger
                let maxThreat = 0;
                let threatAngle = null;
                for (let i = 0; i < this.BANDS.DIR_LEN; i++) {
                    const v = sensory[this.BANDS.DIR_START + i];
                    if (v > maxThreat) {
                        maxThreat = v;
                        threatAngle = (i / this.BANDS.DIR_LEN) * 2 * Math.PI - Math.PI;
                    }
                }
                
                const fleeThreshold = drives.mating > 0.5 || drives.hunger > 0.7 ? 6.0 : 4.0;
                if (maxThreat > fleeThreshold && threatAngle !== null) {
                    const escapeAngle = threatAngle + Math.PI;
                    const normalizedAngle = ((escapeAngle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                    const directionIndex = Math.round((normalizedAngle / (Math.PI / 2))) % 4;
                    const dirs = ['RIGHT', 'DOWN', 'LEFT', 'UP'];
                    
                    this.currentStrategy = 'FLEE_' + dirs[directionIndex];
                    console.log(`FLEEING! Threat=${maxThreat.toFixed(2)}`);
                    return { type: 'MOVE', direction: dirs[directionIndex] };
                }
                
                // Active mate seeking
                if (drives.mating > 0.5) {
                    const nearest = game.npcFlies.reduce((closest, npc) => {
                        const dist = Math.abs(npc.q - game.player.q) + Math.abs(npc.r - game.player.r);
                        return dist < closest.dist ? { npc, dist } : closest;
                    }, { dist: Infinity, npc: null });
                    
                    if (nearest.npc && nearest.dist < 15) {
                        const dq = nearest.npc.q - game.player.q;
                        const dr = nearest.npc.r - game.player.r;
                        const dir = this.chooseSafeDirection(game, dq, dr);
                        this.currentStrategy = 'SEEK_MATE';
                        return { type: 'MOVE', direction: dir };
                    }
                }
                
                // Active food seeking
                if (drives.hunger > 0.4 || game.player.energy < 40) {
                    const foodTargets = game.foodSources.filter(f => {
                        if (f.respawnTimer > 0) return false;
                        if (f.type === 'DNA' && game.player.genome.slots[f.gene]) return false;
                        return true;
                    });
                    
                    if (foodTargets.length > 0) {
                        const nearest = foodTargets.reduce((closest, food) => {
                            const dist = Math.abs(food.q - game.player.q) + Math.abs(food.r - game.player.r);
                            return dist < closest.dist ? { food, dist } : closest;
                        }, { dist: Infinity, food: null });
                        
                        if (nearest.food && nearest.dist < 15) {
                            const dq = nearest.food.q - game.player.q;
                            const dr = nearest.food.r - game.player.r;
                            const dir = this.chooseSafeDirection(game, dq, dr);
                            this.currentStrategy = 'SEEK_FOOD';
                            return { type: 'MOVE', direction: dir };
                        }
                    }
                }
                
                // LAL gated exploration (integrates CX heading + MB valence)
                const lalAction = this.lal.step(this.cx.getHeading(), mbValence, drives);
                
                // If LAL signal is weak, use memory-guided exploration
                if (Math.max(...this.lal.ch) < 0.3) {
                    const dir = this.exploreWithMemory(game);
                    this.currentStrategy = 'EXPLORE_MEM';
                    return { type: 'MOVE', direction: dir };
                }
                
                this.currentStrategy = 'LAL_' + lalAction;
                return { type: 'MOVE', direction: lalAction };
            }
            
            encodeSensory(game) {
                const sensory = new Float32Array(4096);
                const {DIR_START, DIR_LEN, CHEM_START, CHEM_LEN, INT_START} = this.BANDS;
                const visualRes = DIR_LEN;
                
                // Threats
                game.predators.forEach(pred => {
                    const dq = pred.q - game.player.q;
                    const dr = pred.r - game.player.r;
                    const dist = Math.abs(dq) + Math.abs(dr);
                    const angle = Math.atan2(dr, dq);
                    const threat = Math.max(0, 12.0 * (1 - dist / 10));
                    
                    if (threat > 0.1) {
                        const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                        for (let offset = -30; offset <= 30; offset++) {
                            const i = (DIR_START + ((idx + offset + visualRes) % visualRes));
                            sensory[i] = Math.max(sensory[i], threat * Math.exp(-offset * offset / 80));
                        }
                    }
                });
                
                // Food
                const hungerBoost = game.player.energy < 50 ? 2.0 : 1.0;
                game.foodSources.forEach(food => {
                    if (food.type === 'DNA' && game.player.genome.slots[food.gene]) return;
                    if (food.respawnTimer > 0) return;
                    
                    const dq = food.q - game.player.q;
                    const dr = food.r - game.player.r;
                    const dist = Math.sqrt(dq * dq + dr * dr);
                    const angle = Math.atan2(dr, dq);
                    const baseSalience = food.type === 'ENERGY' ? 6.0 : 4.0;
                    const foodSignal = Math.max(0, baseSalience * hungerBoost * (1 - dist / 20));
                    
                    const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                    for (let offset = -15; offset <= 15; offset++) {
                        const i = (DIR_START + ((idx + offset + visualRes) % visualRes));
                        sensory[i] += foodSignal * Math.exp(-offset * offset / 30) * 0.5;
                    }
                });
                
                // Chemosensory (for AL)
                for (let i = 0; i < CHEM_LEN; i++) {
                    const angle = (i / CHEM_LEN) * 2 * Math.PI;
                    const dx = Math.cos(angle);
                    const dy = Math.sin(angle);
                    
                    let smell = 0;
                    game.foodSources.forEach(food => {
                        if (food.respawnTimer > 0) return;
                        if (food.type === 'DNA' && game.player.genome.slots[food.gene]) return;
                        
                        const dq = food.q - game.player.q;
                        const dr = food.r - game.player.r;
                        const dist = Math.sqrt(dq * dq + dr * dr);
                        const dot = (dq * dx + dr * dy) / (dist + 0.01);
                        
                        if (dot > 0.7) {
                            const smellStrength = food.type === 'ENERGY' ? 0.8 : 1.2;
                            smell += Math.max(0, smellStrength * (1.0 - dist / 30) * dot);
                        }
                    });
                    
                    sensory[CHEM_START + i] = smell * hungerBoost;
                }
                
                // Mates
                if (game.player.stage === 'ADULT' && !game.brood) {
                    game.npcFlies.forEach(npc => {
                        const dq = npc.q - game.player.q;
                        const dr = npc.r - game.player.r;
                        const dist = Math.sqrt(dq * dq + dr * dr);
                        const angle = Math.atan2(dr, dq);
                        const mateSignal = Math.max(0, 7.0 * (1 - dist / 18));
                        
                        const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                        for (let offset = -18; offset <= 18; offset++) {
                            const i = (DIR_START + ((idx + offset + visualRes) % visualRes));
                            sensory[i] += mateSignal * Math.exp(-offset * offset / 35) * 0.6;
                        }
                    });
                }
                
                // Internal state
                sensory[INT_START + 0] = game.player.stage === 'LARVA' ? 5.0 : 0.0;
                sensory[INT_START + 1] = game.player.stage === 'PUPA' ? 5.0 : 0.0;
                sensory[INT_START + 2] = game.player.stage === 'ADULT' ? 5.0 : 0.0;
                sensory[INT_START + 3] = (game.player.age / game.player.maxAge) * 4.0;
                sensory[INT_START + 4] = (game.player.energy / 100) * 3.0;
                sensory[INT_START + 5] = game.brood ? 10.0 : 0.0;
                
                const onFood = game.foodSources.some(f => f.q === game.player.q && f.r === game.player.r && f.respawnTimer === 0);
                sensory[INT_START + 6] = onFood ? 8.0 : 0.0;
                
                const nearMate = game.npcFlies.some(n => Math.abs(n.q - game.player.q) + Math.abs(n.r - game.player.r) <= 2);
                sensory[INT_START + 7] = (nearMate && game.player.stage === 'ADULT' && !game.brood) ? 9.0 : 0.0;
                
                if (game.player.energy < 40) {
                    sensory[INT_START + 8] = 12.0;
                } else if (game.player.energy < 60) {
                    sensory[INT_START + 8] = 6.0;
                } else {
                    sensory[INT_START + 8] = 0.0;
                }
                
                if (game.player.stage === 'ADULT' && !game.brood) {
                    sensory[INT_START + 9] = 12.0;
                }
                
                // Memory-based danger
                const dangerDirs = [
                    { angle: 0, dq: 1, dr: 0 },
                    { angle: Math.PI/4, dq: 1, dr: -1 },
                    { angle: Math.PI/2, dq: 0, dr: -1 },
                    { angle: 3*Math.PI/4, dq: -1, dr: -1 },
                    { angle: Math.PI, dq: -1, dr: 0 },
                    { angle: 5*Math.PI/4, dq: -1, dr: 1 },
                    { angle: 3*Math.PI/2, dq: 0, dr: 1 },
                    { angle: 7*Math.PI/4, dq: 1, dr: 1 }
                ];
                
                dangerDirs.forEach(dir => {
                    let memDanger = 0;
                    for (let dist = 1; dist <= 3; dist++) {
                        const checkQ = game.player.q + dir.dq * dist;
                        const checkR = game.player.r + dir.dr * dist;
                        const key = `${checkQ},${checkR}`;
                        
                        if (this.dangerMap.has(key)) {
                            const danger = this.dangerMap.get(key);
                            memDanger += danger.threat / dist;
                        }
                    }
                    
                    if (memDanger > 0.1) {
                        const idx = Math.floor(((dir.angle + Math.PI) / (2 * Math.PI)) * visualRes);
                        for (let offset = -10; offset <= 10; offset++) {
                            const sIdx = (DIR_START + ((idx + offset + visualRes) % visualRes));
                            sensory[sIdx] += memDanger * Math.exp(-offset * offset / 20) * 0.3;
                        }
                    }
                });
                
                return sensory;
            }
            
            computeReward(game) {
                let r = 0;
                r += game.player.energy * 2;
                r += Object.keys(game.player.genome.slots).filter(k => game.player.genome.slots[k]).length * 30;
                r += game.player.stage === 'ADULT' ? 60 : 0;
                
                const dists = game.predators.map(p => Math.abs(p.q - game.player.q) + Math.abs(p.r - game.player.r));
                const minPredDist = dists.length ? Math.min(...dists) : 99;
                r += minPredDist > 4 ? 40 : (minPredDist < 2 ? -100 : -20);
                
                return r;
            }
            
            // Scoring & achievements
            addScore(points, reason) {
                this.score += points;
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('mobius_high_score', this.highScore.toString());
                }
                console.log(`+${points} pts: ${reason} (Total: ${this.score})`);
                this.checkAchievements();
            }
            
            onMating() {
                this.totalMates++;
                this.addScore(500, 'MATING SUCCESS');
            }
            
            onFeeding(type) {
                this.totalFood++;
                if (type === 'DNA') {
                    this.totalDNA++;
                    this.addScore(200, 'DNA ACQUIRED');
                } else {
                    this.addScore(50, 'ENERGY FOOD');
                }
            }
            
            onGeneration(gen) {
                this.generationsReached = Math.max(this.generationsReached, gen);
                this.addScore(gen * 100, `GEN ${gen} REACHED`);
                
                // Clear spatial memory
                this.dangerMap.clear();
                this.visitedTiles.clear();
                this.boundaryMemory.clear();
                this.boundaryLoopBreaker = 0;
                this.recentWraps = [];
                console.log('Memory cleared for new generation');
            }
            
            onBoundaryWrap(q, r) {
                const key = `${q},${r}`;
                this.boundaryMemory.set(key, this.tick);
                
                let destQ = q;
                let destR = r;
                
                if (q < -15) destQ = 15;
                else if (q > 15) destQ = -15;
                
                if (r < -10) destR = 10;
                else if (r > 10) destR = -10;
                
                const destKey = `${destQ},${destR}`;
                this.boundaryMemory.set(destKey, this.tick);
                
                if (!this.recentWraps) this.recentWraps = [];
                this.recentWraps.push(this.tick);
                if (this.recentWraps.length > 5) this.recentWraps.shift();
                
                if (this.recentWraps.length === 5 && (this.tick - this.recentWraps[0]) < 10) {
                    console.log('BOUNDARY LOOP DETECTED!');
                    this.boundaryLoopBreaker = 10;
                }
            }
            
            onSurvival(age, stage) {
                const points = stage === 'ADULT' ? 5 : 2;
                this.addScore(points, 'SURVIVAL');
                this.longestLife = Math.max(this.longestLife, age);
            }
            
            onMovement(dist) {
                this.totalDistance += dist;
                if (this.totalDistance % 50 === 0) {
                    this.addScore(10, 'EXPLORATION');
                }
            }
            
            checkPlateaus(genome) {
                const plateau = this.museum.checkAndSave(genome);
                if (plateau) {
                    this.addScore(500, `PLATEAU DISCOVERED`);
                    if (window.gameScene) {
                        window.gameScene.log(`‚òÖ PLATEAU: ${plateau.name}!`, '#ffd700');
                    }
                }
            }
            
            checkAchievements() {
                const achievements = [
                    { id: 'first_mate', check: () => this.totalMates >= 1, msg: 'üéâ First Mate!' },
                    { id: 'breeder', check: () => this.totalMates >= 5, msg: 'üíï Breeder - 5 Mates!' },
                    { id: 'prolific', check: () => this.totalMates >= 10, msg: 'üëë Prolific - 10 Mates!' },
                    { id: 'first_gen', check: () => this.generationsReached >= 2, msg: 'üß¨ Generation 2!' },
                    { id: 'dynasty', check: () => this.generationsReached >= 5, msg: 'üèÜ Dynasty - Gen 5!' },
                    { id: 'collector', check: () => this.totalDNA >= 3, msg: 'üß™ Collector - 3 DNA!' },
                    { id: 'complete', check: () => this.totalDNA >= 4, msg: 'üíé Complete Genome!' },
                    { id: 'explorer', check: () => this.totalDistance >= 100, msg: 'üó∫Ô∏è Explorer - 100 tiles!' },
                    { id: 'survivor', check: () => this.longestLife >= 200, msg: '‚è∞ Survivor - 200 turns!' },
                    { id: 'high_score', check: () => this.score >= 2000, msg: '‚≠ê Score 2000!' },
                ];
                
                achievements.forEach(ach => {
                    if (!this.achievementsUnlocked.has(ach.id) && ach.check()) {
                        this.achievementsUnlocked.add(ach.id);
                        console.log(`üèÜ ACHIEVEMENT: ${ach.msg}`);
                        this.addScore(250, 'ACHIEVEMENT');
                        if (window.gameScene) {
                            window.gameScene.showAchievementNotification(ach.msg);
                        }
                    }
                });
            }
        }
        
        // ============================================================================
        // GAME SCENE (Part 1)
        // ============================================================================
        
        const LOCI = {
            Notch: { class: 'Core', effects: { viability: 15 }, instability: 0 },
            Egfr: { class: 'Core', effects: { viability: 12 }, instability: 0 },
            hh: { class: 'Core', effects: { viability: 10 }, instability: 1 },
            wg: { class: 'Core', effects: { viability: 10 }, instability: 1 },
            vg: { class: 'Sensorimotor', effects: { flight: 8 }, instability: 1 },
            Hsp70: { class: 'Metabolic', effects: { heat_tol: 12 }, instability: 1 },
            InR: { class: 'Metabolic', effects: { energy: 8 }, instability: 2 },
            Orco: { class: 'Sensorimotor', effects: { olfaction: 10 }, instability: 1 },
            Adh: { class: 'Metabolic', effects: { ferment_tol: 10 }, instability: 1 },
            Drip: { class: 'Metabolic', effects: { desiccation: 10 }, instability: 1 },
        };
        
        class HexGrid {
            constructor(hexSize) {
                this.hexSize = hexSize;
                this.seamLine = 0;
            }
            
            hexToPixel(q, r) {
                const x = this.hexSize * (3/2 * q);
                const y = this.hexSize * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
                return { x, y };
            }
            
            crossesSeam(r_from, r_to) {
                return (r_from < this.seamLine && r_to >= this.seamLine) ||
                       (r_from >= this.seamLine && r_to < this.seamLine);
            }
            
            drawHexagon(graphics, x, y, size, color, alpha = 1) {
                graphics.fillStyle(color, alpha);
                graphics.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    const hx = x + size * Math.cos(angle);
                    const hy = y + size * Math.sin(angle);
                    if (i === 0) graphics.moveTo(hx, hy);
                    else graphics.lineTo(hx, hy);
                }
                graphics.closePath();
                graphics.fillPath();
                graphics.lineStyle(2, 0x333333, 0.8);
                graphics.strokePath();
            }
        }
        
        class EoPSystem {
            calculateCF(fly, tile, posture = 'DEFAULT') {
                let cf = tile.cf_base || 0;
                if (fly.inHeat) cf += 1;
                if (posture === 'GREEDY_SURGE') cf += 1;
                if (posture === 'SAFE_BUFFER') cf -= 1;
                return Math.max(0, cf);
            }
            
            roll(fly, item, cf, posture = 'DEFAULT') {
                const instability = fly.genome.instability || 0;
                let p_SI = 0.40, p_CS = 0.05;
                
                if (fly.stage === 'LARVA') p_SI += 0.10;
                if (instability > 8) p_CS += 0.05;
                if (cf > 2) p_CS += 0.05;
                
                const roll = Math.random();
                
                if (roll < p_SI) {
                    return { outcome: 'SI', instability: -1, score: 200 };
                }
                if (roll > 0.95) {
                    return { outcome: 'CS', instability: 2, stun: 2, score: -50 };
                }
                return { outcome: 'MF', instability: 0, score: 50 };
            }
        }
        
        // ============================================================================
        // GAME SCENE - Complete
        // ============================================================================
        
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                this.agent = new FruitFlyAgent();
                this.eopSystem = new EoPSystem();
            }
            
            create() {
                this.cameras.main.setBackgroundColor('#1a1a1a');
                this.hexSize = 28;
                this.hexGrid = new HexGrid(this.hexSize);
                this.tiles = [];
                this.foodSources = [];
                this.predators = [];
                this.npcFlies = [];
                this.generation = 1;
                
                window.gameScene = this;
                this.seamCrossings = 0;
                
                this.generateWorld();
                
                this.hexGraphics = this.add.graphics();
                this.foodGraphics = this.add.graphics();
                this.predatorGraphics = this.add.graphics();
                this.npcGraphics = this.add.graphics();
                
                this.drawWorld();
                
                this.player = {
                    q: 0, r: 0, stage: 'LARVA', turn: 0, age: 0, maxAge: 30,
                    energy: 100,
                    genome: {
                        slots: { Notch: true, Egfr: true, hh: true, wg: true },
                        instability: 3
                    },
                    inventory: [], 
                    alive: true,
                    parityFlipped: false,
                    posture: 'DEFAULT',
                    inHeat: false,
                    stunned: 0
                };
                
                this.playerSprite = this.add.circle(0, 0, 10, 0xFF6B6B).setDepth(100);
                this.updatePlayerSprite();
                
                this.cameras.main.startFollow(this.playerSprite, true, 0.1, 0.1);
                this.cameras.main.setZoom(1.2);
                
                this.setupInput();
                this.updateAllUI();
                
                this.brood = null;
                
                console.log('ü™∞ Fruit Fly Brain - ONLINE!');
                console.log('AI AUTO-ENABLED! Press A to toggle');
                
                // AI tick
                this.time.addEvent({
                    delay: 200,
                    callback: () => {
                        if (!this.agent.active || !this.player.alive) return;
                        const action = this.agent.decide(this);
                        if (action) this.executeAction(action);
                    },
                    loop: true
                });
                
                // Energy drain
                this.time.addEvent({
                    delay: 2000,
                    callback: () => {
                        if (this.player.alive) {
                            this.player.energy = Math.max(0, this.player.energy - 1);
                            if (this.player.energy <= 0) this.die('starvation');
                            this.updateAllUI();
                        }
                    },
                    loop: true
                });
                
                // NPC/Pred updates
                this.time.addEvent({
                    delay: 1000,
                    callback: () => {
                        this.updateNPCs();
                        this.updatePredators();
                    },
                    loop: true
                });
                
                // Food respawn
                this.time.addEvent({
                    delay: 500,
                    callback: () => {
                        this.foodSources.forEach(f => {
                            if (f.respawnTimer > 0) {
                                f.respawnTimer--;
                                if (f.respawnTimer === 0) this.drawWorld();
                            }
                        });
                    },
                    loop: true
                });
            }
            
            generateWorld() {
                // Tiles
                for (let q = -15; q <= 15; q++) {
                    for (let r = -10; r <= 10; r++) {
                        const pos = this.hexGrid.hexToPixel(q, r);
                        this.tiles.push({ q, r, x: pos.x, y: pos.y });
                    }
                }
                
                // Food
                const foodDefs = [
                    { q: 3, r: 2, type: 'DNA', gene: 'vg', color: 0x8B4513, cf_base: 0 },
                    { q: -4, r: 3, type: 'DNA', gene: 'Hsp70', color: 0xFFA500, cf_base: 1 },
                    { q: 5, r: -2, type: 'DNA', gene: 'InR', color: 0xD2B48C, cf_base: 0 },
                    { q: -2, r: -4, type: 'DNA', gene: 'Orco', color: 0xFFFF99, cf_base: 1 },
                    { q: 8, r: 3, type: 'DNA', gene: 'Adh', color: 0xCD853F, cf_base: 0 },
                    { q: -7, r: -2, type: 'DNA', gene: 'Drip', color: 0xDEB887, cf_base: 1 },
                    { q: 7, r: 1, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: -6, r: -1, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 2, r: 5, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: -8, r: 4, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 10, r: -4, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: -3, r: 7, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 12, r: 2, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: -10, r: -5, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 0, r: -8, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 8, r: 6, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: -5, r: -7, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 4, r: -6, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                ];
                
                foodDefs.forEach(f => this.foodSources.push({ ...f, respawnTimer: 0 }));
                
                // NPCs
                [
                    { q: 4, r: 4 }, { q: -5, r: 3 }, { q: 6, r: -3 },
                    { q: -7, r: 5 }, { q: 9, r: -2 }, { q: 3, r: -5 }
                ].forEach(pos => {
                    this.npcFlies.push({
                        q: pos.q, r: pos.r, stage: 'ADULT',
                        genome: { slots: { Notch: true, Egfr: true, hh: true, wg: true }, instability: 3 }
                    });
                });
                
                // Predators
                [
                    { q: -8, r: -3, type: 'JUMPING_SPIDER', color: 0xff0000, speed: 1, vision: 3, behavior: 'chase' },
                    { q: 10, r: 5, type: 'DRAGONFLY', color: 0xff6600, speed: 2, vision: 4, behavior: 'patrol' },
                    { q: -5, r: 8, type: 'ORB_SPIDER', color: 0xaa0000, speed: 0, vision: 2, behavior: 'web' }
                ].forEach(pos => {
                    this.predators.push({
                        q: pos.q, r: pos.r, 
                        type: pos.type,
                        color: pos.color,
                        speed: pos.speed, 
                        vision: pos.vision,
                        behavior: pos.behavior,
                        patrolDir: 1,
                        patrolCount: 0
                    });
                });
            }
            
            drawWorld() {
                this.hexGraphics.clear();
                this.tiles.forEach(tile => {
                    this.hexGrid.drawHexagon(this.hexGraphics, tile.x, tile.y, this.hexSize, 0x2d4a2d, 0.5);
                });
                
                this.foodGraphics.clear();
                this.foodSources.forEach(food => {
                    if (food.respawnTimer > 0) return;
                    const pos = this.hexGrid.hexToPixel(food.q, food.r);
                    if (food.type === 'DNA') {
                        this.foodGraphics.fillStyle(food.color, 0.9);
                        this.foodGraphics.fillRect(pos.x - 8, pos.y - 8, 16, 16);
                        this.foodGraphics.lineStyle(2, 0xffffff, 0.8);
                        this.foodGraphics.strokeRect(pos.x - 8, pos.y - 8, 16, 16);
                    } else {
                        this.foodGraphics.fillStyle(food.color, 0.8);
                        this.foodGraphics.fillCircle(pos.x, pos.y, 10);
                        this.foodGraphics.lineStyle(2, 0xffffff, 0.6);
                        this.foodGraphics.strokeCircle(pos.x, pos.y, 10);
                    }
                });
            }
            
            updatePlayerSprite() {
                const pos = this.hexGrid.hexToPixel(this.player.q, this.player.r);
                this.playerSprite.setPosition(pos.x, pos.y);
                const size = this.player.stage === 'ADULT' ? 12 : (this.player.stage === 'PUPA' ? 8 : 10);
                this.playerSprite.setRadius(size);
            }
            
            setupInput() {
                this.cursors = this.input.keyboard.createCursorKeys();
                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.input.keyboard.addKey('E').on('down', () => { if (!this.agent.active) this.feed(); });
                this.input.keyboard.addKey('M').on('down', () => { if (!this.agent.active) this.mate(); });
                this.input.keyboard.addKey('A').on('down', () => this.toggleAI());
                
                for (let i = 1; i <= 9; i++) {
                    this.input.keyboard.addKey(`${i}`).on('down', () => {
                        if (this.brood && !this.agent.active) this.selectOffspring(i - 1);
                    });
                }
            }
            
            toggleAI() {
                const active = this.agent.toggle();
                document.getElementById('ai-status').innerHTML = active ? 
                    'Status: <span class="brain">THINKING</span>' : 
                    'Status: <span class="brain">OFF</span>';
                console.log(active ? 'AI ENABLED' : 'AI DISABLED');
            }
            
            update() {
                if (!this.player.alive || this.agent.active) return;
                
                if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
                    this.passTurn();
                    return;
                }
                
                let direction = null;
                if (Phaser.Input.Keyboard.JustDown(this.cursors.up)) direction = 'UP';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.down)) direction = 'DOWN';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.left)) direction = 'LEFT';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.right)) direction = 'RIGHT';
                
                if (direction) this.moveInDirection(direction);
            }
            
            moveInDirection(direction) {
                let newQ = this.player.q;
                let newR = this.player.r;
                
                if (direction === 'UP') newR -= 1;
                if (direction === 'DOWN') newR += 1;
                if (direction === 'LEFT') newQ -= 1;
                if (direction === 'RIGHT') newQ += 1;
                
                if (newQ < -15) {
                    newQ = 15;
                    this.agent.onBoundaryWrap(this.player.q, this.player.r);
                }
                if (newQ > 15) {
                    newQ = -15;
                    this.agent.onBoundaryWrap(this.player.q, this.player.r);
                }
                
                if (newR < -10) {
                    newR = 10;
                    this.player.parityFlipped = !this.player.parityFlipped;
                    this.log('M√∂bius wrap: top‚Üíbottom', '#00ffff');
                    this.agent.addScore(25, 'TOPOLOGY');
                    this.agent.onBoundaryWrap(this.player.q, this.player.r);
                } else if (newR > 10) {
                    newR = -10;
                    this.player.parityFlipped = !this.player.parityFlipped;
                    this.log('M√∂bius wrap: bottom‚Üítop', '#00ffff');
                    this.agent.addScore(25, 'TOPOLOGY');
                    this.agent.onBoundaryWrap(this.player.q, this.player.r);
                }
                
                if (this.hexGrid.crossesSeam(this.player.r, newR)) {
                    this.player.parityFlipped = !this.player.parityFlipped;
                    this.seamCrossings++;
                    this.log('Seam crossed!', '#00ffff');
                    this.agent.addScore(10, 'TOPOLOGY');
                }
                
                this.player.q = newQ;
                this.player.r = newR;
                this.player.turn++;
                this.player.age++;
                
                this.agent.onMovement(1);
                
                if (this.player.age % 10 === 0) {
                    this.agent.onSurvival(this.player.age, this.player.stage);
                }
                
                this.checkLifecycleAdvancement();
                this.checkPredators();
                this.updatePlayerSprite();
                this.updateAllUI();
                this.drawWorld();
            }
            
            passTurn() {
                this.player.turn++;
                this.player.age++;
                this.checkLifecycleAdvancement();
                this.updateAllUI();
            }
            
            checkLifecycleAdvancement() {
                if (this.player.age >= this.player.maxAge) {
                    const stages = ['LARVA', 'PUPA', 'ADULT'];
                    const idx = stages.indexOf(this.player.stage);
                    if (idx < stages.length - 1) {
                        this.player.stage = stages[idx + 1];
                        this.player.age = 0;
                        this.player.maxAge = this.player.stage === 'ADULT' ? 300 : 30;
                        this.log(`‚üπ ${this.player.stage}`, '#ffff00');
                        this.updatePlayerSprite();
                    } else {
                        this.die('old age');
                    }
                }
            }
            
            feed() {
                const food = this.foodSources.find(f => f.q === this.player.q && f.r === this.player.r && f.respawnTimer === 0);
                if (!food) return;
                
                if (food.type === 'ENERGY') {
                    this.player.energy = Math.min(100, this.player.energy + 30);
                    this.log('‚úì Energy +30', '#00ff00');
                    this.createParticleEffect(this.player.q, this.player.r, 0x00ff00, 10);
                    this.agent.onFeeding('ENERGY');
                } else {
                    if (!this.player.genome.slots[food.gene]) {
                        const cf = this.eopSystem.calculateCF(this.player, food, this.player.posture);
                        const result = this.eopSystem.roll(this.player, food.gene, cf, this.player.posture);
                        
                        if (result.outcome === 'SI') {
                            this.player.genome.slots[food.gene] = true;
                            this.player.genome.instability = Math.max(0, this.player.genome.instability + result.instability);
                            this.log(`~ DNA: ${food.gene} [SI]`, '#00ffff');
                            this.createParticleEffect(this.player.q, this.player.r, food.color, 15);
                            this.agent.onFeeding('DNA');
                            this.agent.checkPlateaus(this.player.genome);
                        } else if (result.outcome === 'CS') {
                            this.player.genome.instability += result.instability;
                            this.player.stunned = result.stun;
                            this.log(`‚úò DNA: ${food.gene} [CS]`, '#ff0000');
                            this.createParticleEffect(this.player.q, this.player.r, 0xff0000, 20);
                            this.agent.addScore(result.score, 'CRITICAL FAILURE');
                        } else {
                            this.player.genome.slots[food.gene] = true;
                            this.player.genome.instability += result.instability;
                            this.log(`~ DNA: ${food.gene} [MF]`, '#ffff00');
                            this.createParticleEffect(this.player.q, this.player.r, food.color, 10);
                            this.agent.addScore(result.score, 'DNA MIXED');
                            this.agent.checkPlateaus(this.player.genome);
                        }
                    }
                    this.player.energy = Math.min(100, this.player.energy + 10);
                }
                
                food.respawnTimer = 10;
                this.drawWorld();
                this.updateAllUI();
            }
            
            mate() {
                if (this.player.stage !== 'ADULT' || this.brood) return;
                const near = this.npcFlies.find(n => Math.abs(n.q - this.player.q) + Math.abs(n.r - this.player.r) <= 2);
                if (!near) return;
                
                this.brood = [];
                for (let i = 0; i < 8; i++) {
                    this.brood.push({
                        id: i + 1,
                        genome: JSON.parse(JSON.stringify(this.player.genome))
                    });
                }
                
                this.log('‚ïê‚ïê‚ïê BROOD LAID ‚ïê‚ïê‚ïê', '#ff69b4');
                this.createParticleEffect(this.player.q, this.player.r, 0xff69b4, 20);
                this.agent.onMating();
                document.getElementById('has-brood').style.display = 'block';
            }
            
            log(msg, color = '#00ff00') {
                console.log(msg);
            }
            
            showAchievementNotification(msg) {
                const notification = this.add.text(450, 100, msg, {
                    fontSize: '24px',
                    fontFamily: 'Courier New',
                    fontStyle: 'bold',
                    color: '#ffff00',
                    backgroundColor: '#000000',
                    padding: { x: 20, y: 10 }
                });
                notification.setOrigin(0.5);
                notification.setScrollFactor(0);
                notification.setDepth(1000);
                
                this.tweens.add({
                    targets: notification,
                    y: 80,
                    duration: 200,
                    ease: 'Back.easeOut'
                });
                
                this.time.delayedCall(3000, () => {
                    this.tweens.add({
                        targets: notification,
                        alpha: 0,
                        y: 60,
                        duration: 500,
                        onComplete: () => notification.destroy()
                    });
                });
            }
            
            createParticleEffect(q, r, color, count) {
                const pos = this.hexGrid.hexToPixel(q, r);
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 100;
                    const particle = this.add.circle(pos.x, pos.y, 3, color);
                    particle.setAlpha(0.8);
                    
                    this.tweens.add({
                        targets: particle,
                        x: pos.x + Math.cos(angle) * speed,
                        y: pos.y + Math.sin(angle) * speed,
                        alpha: 0,
                        duration: 500 + Math.random() * 500,
                        onComplete: () => particle.destroy()
                    });
                }
            }
            
            selectOffspring(index) {
                if (!this.brood || index >= this.brood.length) return;
                
                this.generation++;
                this.log(`‚ïê‚ïê‚ïê GEN ${this.generation} ‚ïê‚ïê‚ïê`, '#ffff00');
                this.agent.onGeneration(this.generation);
                
                this.player.genome = JSON.parse(JSON.stringify(this.brood[index].genome));
                this.player.stage = 'LARVA';
                this.player.age = 0;
                this.player.maxAge = 30;
                this.player.energy = 100;
                this.player.q = 0;
                this.player.r = 0;
                this.player.alive = true;
                
                this.brood = null;
                document.getElementById('has-brood').style.display = 'none';
                
                this.updatePlayerSprite();
                this.updateAllUI();
            }
            
            checkPredators() {
                this.predators.forEach(pred => {
                    const dist = Math.abs(pred.q - this.player.q) + Math.abs(pred.r - this.player.r);
                    if (dist <= 1) this.die('predation');
                });
            }
            
            updatePredators() {
                this.predators.forEach(pred => {
                    if (Math.random() < 0.4) {
                        if (pred.behavior === 'chase' && pred.speed > 0) {
                            const dq = this.player.q - pred.q;
                            const dr = this.player.r - pred.r;
                            const dist = Math.abs(dq) + Math.abs(dr);
                            
                            if (dist <= pred.vision) {
                                if (Math.abs(dq) > Math.abs(dr)) {
                                    pred.q += Math.sign(dq);
                                } else {
                                    pred.r += Math.sign(dr);
                                }
                            }
                        } else if (pred.behavior === 'patrol' && pred.speed > 0) {
                            pred.patrolCount++;
                            if (pred.patrolCount >= 4) {
                                pred.patrolCount = 0;
                                pred.patrolDir *= -1;
                            }
                            
                            if (Math.random() < 0.5) {
                                pred.q += pred.patrolDir * pred.speed;
                            } else {
                                pred.r += pred.patrolDir * pred.speed;
                            }
                        }
                    }
                });
                this.drawPredators();
            }
            
            drawPredators() {
                this.predatorGraphics.clear();
                this.predators.forEach(pred => {
                    const pos = this.hexGrid.hexToPixel(pred.q, pred.r);
                    
                    this.predatorGraphics.fillStyle(pred.color, 0.1);
                    this.predatorGraphics.fillCircle(pos.x, pos.y, this.hexSize * pred.vision);
                    
                    this.predatorGraphics.fillStyle(pred.color, 0.9);
                    this.predatorGraphics.lineStyle(3, pred.color, 1);
                    
                    if (pred.type === 'JUMPING_SPIDER') {
                        this.predatorGraphics.beginPath();
                        this.predatorGraphics.moveTo(pos.x - 8, pos.y - 8);
                        this.predatorGraphics.lineTo(pos.x + 8, pos.y + 8);
                        this.predatorGraphics.moveTo(pos.x + 8, pos.y - 8);
                        this.predatorGraphics.lineTo(pos.x - 8, pos.y + 8);
                        this.predatorGraphics.strokePath();
                    } else if (pred.type === 'DRAGONFLY') {
                        this.predatorGraphics.beginPath();
                        this.predatorGraphics.moveTo(pos.x, pos.y - 10);
                        this.predatorGraphics.lineTo(pos.x + 7, pos.y);
                        this.predatorGraphics.lineTo(pos.x, pos.y + 10);
                        this.predatorGraphics.lineTo(pos.x - 7, pos.y);
                        this.predatorGraphics.closePath();
                        this.predatorGraphics.fillPath();
                        this.predatorGraphics.strokePath();
                    } else if (pred.type === 'ORB_SPIDER') {
                        this.predatorGraphics.fillCircle(pos.x, pos.y, 6);
                        for (let i = 0; i < 8; i++) {
                            const angle = i * Math.PI / 4;
                            this.predatorGraphics.beginPath();
                            this.predatorGraphics.moveTo(pos.x, pos.y);
                            this.predatorGraphics.lineTo(
                                pos.x + Math.cos(angle) * 15,
                                pos.y + Math.sin(angle) * 15
                            );
                            this.predatorGraphics.strokePath();
                        }
                    }
                });
            }
            
            updateNPCs() {
                this.npcFlies.forEach(npc => {
                    if (Math.random() < 0.5) {
                        const dirs = [{ q: 0, r: -1 }, { q: 0, r: 1 }, { q: -1, r: 0 }, { q: 1, r: 0 }];
                        const dir = dirs[Math.floor(Math.random() * dirs.length)];
                        npc.q += dir.q;
                        npc.r += dir.r;
                    }
                });
                this.drawNPCs();
            }
            
            drawNPCs() {
                this.npcGraphics.clear();
                this.npcFlies.forEach(npc => {
                    const pos = this.hexGrid.hexToPixel(npc.q, npc.r);
                    this.npcGraphics.fillStyle(0xFF69B4, 0.8);
                    this.npcGraphics.fillCircle(pos.x, pos.y, 8);
                });
            }
            
            die(cause) {
                this.player.alive = false;
                this.log(`‚úò DEATH: ${cause}`, '#ff0000');
                
                this.time.delayedCall(2000, () => {
                    this.generation++;
                    this.player.stage = 'LARVA';
                    this.player.age = 0;
                    this.player.maxAge = 30;
                    this.player.energy = 100;
                    this.player.q = 0;
                    this.player.r = 0;
                    this.player.alive = true;
                    this.updatePlayerSprite();
                    this.updateAllUI();
                });
            }
            
            executeAction(action) {
                if (action.type === 'MOVE') {
                    this.moveInDirection(action.direction);
                } else if (action.type === 'FEED') {
                    this.feed();
                    this.player.turn++;
                    this.player.age++;
                } else if (action.type === 'MATE') {
                    this.mate();
                    this.player.turn++;
                } else if (action.type === 'SELECT_OFFSPRING') {
                    this.selectOffspring(action.index);
                }
                
                this.updateAllUI();
            }
            
            updateAllUI() {
                // Lifecycle
                document.getElementById('stage-display').textContent = this.player.stage;
                document.getElementById('age-display').textContent = this.player.age;
                document.getElementById('max-age-display').textContent = this.player.maxAge;
                document.getElementById('gen-display').textContent = this.generation;
                document.getElementById('energy-display').textContent = Math.floor(this.player.energy);
                
                // Genome
                const loci = Object.keys(this.player.genome.slots).filter(k => this.player.genome.slots[k]).length;
                document.getElementById('loci-count').textContent = loci;
                document.getElementById('instability-display').textContent = this.player.genome.instability;
                
                // Topology
                document.getElementById('parity-display').textContent = this.player.parityFlipped ? 'FLIPPED' : 'NORMAL';
                document.getElementById('seam-count').textContent = this.seamCrossings;
                
                // Plateau Museum
                document.getElementById('plateau-count').textContent = this.agent.museum.count;
                const recent = this.agent.museum.getRecent(5);
                const plateauList = document.getElementById('plateau-list');
                if (recent.length > 0) {
                    plateauList.innerHTML = recent.map(p => 
                        `<div style="color:#ffd700">‚òÖ ${p.name} (${p.loci.join(',')})</div>`
                    ).join('');
                } else {
                    plateauList.innerHTML = '<div style="color:#666">None discovered yet</div>';
                }
                
                // Nearby
                document.getElementById('npc-count').textContent = this.npcFlies.length;
                document.getElementById('pred-count').textContent = this.predators.length;
                
                const nearFood = this.foodSources.filter(f => {
                    const dist = Math.abs(f.q - this.player.q) + Math.abs(f.r - this.player.r);
                    return dist <= 5 && f.respawnTimer === 0;
                }).length;
                document.getElementById('food-count').textContent = nearFood;
                
                // Brain stats
                document.getElementById('cx-heading').textContent = Math.floor(this.agent.cx.getHeadingAngle()) + '¬∞';
                const valence = this.agent.mb.getValence();
                document.getElementById('mb-valence').textContent = (valence.approach - valence.avoid).toFixed(2);
                document.getElementById('dopamine').textContent = this.agent.dopamine.toFixed(2);
                document.getElementById('al-active').textContent = this.agent.al.getActiveGlomeruli();
                document.getElementById('ai-strategy').textContent = this.agent.currentStrategy;
                document.getElementById('decisions').textContent = this.agent.decisions;
                
                // Scoring
                document.getElementById('score-display').textContent = this.agent.score;
                document.getElementById('high-score-display').textContent = this.agent.highScore;
                document.getElementById('gens-reached').textContent = this.agent.generationsReached;
                document.getElementById('total-mates').textContent = this.agent.totalMates;
                document.getElementById('total-foods').textContent = this.agent.totalFood;
                document.getElementById('total-dna').textContent = this.agent.totalDNA;
                document.getElementById('total-distance').textContent = this.agent.totalDistance;
                
                // Memory
                document.getElementById('mem-danger').textContent = this.agent.dangerMap.size;
                document.getElementById('mem-visited').textContent = this.agent.visitedTiles.size;
                document.getElementById('mem-boundaries').textContent = this.agent.boundaryMemory.size;
            }
        }
        
        // ============================================================================
        // GAME INITIALIZATION
        // ============================================================================
        
        const config = {
            type: Phaser.AUTO,
            width: 900,
            height: 720,
            parent: 'phaser-canvas',
            backgroundColor: '#1a1a1a',
            scene: [GameScene]
        };
        
        const game = new Phaser.Game(config);
    </script>
</body>
</html>
