<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√∂bius Savanna v7.0 - 100K GPU Brain!</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #game-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #legend {
            width: 360px;
            background: rgba(0, 0, 0, 0.95);
            color: #00ff00;
            padding: 12px;
            overflow-y: auto;
            border-right: 2px solid #00ff00;
            font-size: 10px;
        }
        #legend h3 {
            color: #00ffff;
            margin: 8px 0 4px 0;
            font-size: 12px;
            border-bottom: 1px solid #00ffff;
        }
        #legend .key {
            margin: 3px 0;
            line-height: 1.2;
        }
        #legend .stat {
            color: #ffff00;
            font-weight: bold;
        }
        .section {
            margin-bottom: 10px;
        }
        .warning {
            color: #ff6600;
            font-weight: bold;
        }
        .danger {
            color: #ff0000;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        .quantum {
            color: #00ffff;
            font-weight: bold;
        }
        .plateau {
            color: #00ff00;
            font-weight: bold;
        }
        .ai {
            color: #ff00ff;
            font-weight: bold;
        }
        .mate {
            color: #ff69b4;
            font-weight: bold;
        }
        .gpu {
            color: #00ff00;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .plateau-entry {
            background: rgba(0, 255, 0, 0.1);
            border-left: 2px solid #00ff00;
            padding: 3px;
            margin: 2px 0;
            font-size: 9px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="legend">
            <h2 style="color: #ff6b6b; margin: 0 0 8px 0; font-size: 15px;">M√ñBIUS SAVANNA v7.0</h2>
            <div style="color: #888; font-size: 9px; margin-bottom: 10px;"><span class="gpu">100K GPU</span> | WebGL Compute | Full Fly Brain</div>
            
            <div class="section">
                <h3>CONTROLS</h3>
                <div class="key">‚Üë‚Üì‚Üê‚Üí Move</div>
                <div class="key"><b>SPACE</b> Pass turn</div>
                <div class="key"><b>A</b> Toggle AI</div>
                <div class="key"><b>E</b> Pickup DNA/Food</div>
                <div class="key"><b>M</b> Mate with nearby fly</div>
                <div class="key"><b>1-9</b> Select offspring</div>
            </div>

            <div class="section">
                <h3>SCORE</h3>
                <div class="key">Score: <span id="score-display" class="stat">0</span></div>
                <div class="key">High: <span id="high-score-display" class="stat">0</span></div>
                <div class="key">Gens: <span id="gens-reached" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>LIFETIME STATS</h3>
                <div class="key">Mates: <span id="total-mates" class="stat">0</span></div>
                <div class="key">Foods: <span id="total-food" class="stat">0</span></div>
                <div class="key">DNA: <span id="total-dna" class="stat">0</span></div>
                <div class="key">Dist: <span id="total-dist" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>GPU FIL BRAIN</h3>
                <div class="key" id="ai-status">Status: <span class="ai">OFF</span></div>
                <div class="key">Cells: <span class="gpu">100,000</span></div>
                <div class="key">GPU: <span class="gpu" id="gpu-status">READY</span></div>
                <div class="key">Action: <span id="ai-strategy" class="ai">--</span></div>
                <div class="key">Reward: <span id="ai-fitness" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>LIFECYCLE</h3>
                <div class="key">Stage: <span id="stage-display" class="stat">LARVA</span></div>
                <div class="key">Age: <span id="age-display" class="stat">0</span>/<span id="max-age-display">6</span></div>
                <div class="key">Gen: <span id="gen-display" class="stat">1</span></div>
                <div class="key">Energy: <span id="energy-display" class="stat">100</span>%</div>
                <div class="key" id="death-status" style="display: none;"><span class="danger">DEAD</span></div>
                <div class="key" id="can-mate" style="display: none;"><span class="mate">Can mate!</span></div>
                <div class="key" id="has-brood" style="display: none;"><span class="mate">Brood! Press 1-9</span></div>
            </div>

            <div class="section">
                <h3>GENOME</h3>
                <div class="key">Loci: <span id="loci-count" class="stat">4</span></div>
                <div class="key">Instab: <span id="instability-display" class="stat">3</span></div>
                <div class="key">DNA Items: <span id="dna-count" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>NEARBY</h3>
                <div class="key">NPCs: <span id="npc-count" class="stat">0</span></div>
                <div class="key">Food: <span id="food-count" class="stat">0</span></div>
                <div id="predator-display" style="color: #ff6600; font-size: 9px;">
                    <div class="key">Threats: None</div>
                </div>
            </div>

            <div class="section">
                <h3>SHAPES</h3>
                <div class="key">‚óè You (red)</div>
                <div class="key">‚óè NPCs (pink)</div>
                <div class="key">‚óÜ DNA Food (brown/orange)</div>
                <div class="key">‚óã Energy Food (green)</div>
                <div class="key">‚úñ Predators</div>
            </div>
        </div>
        <div id="phaser-canvas"></div>
    </div>
    
    <script>
        // ============================================================================
        // GPU-ACCELERATED FIL MANIFOLD - 100K CELLS
        // ============================================================================
        
        class GPUFILManifold {
            constructor(n) {
                this.n = n; // 100,000 cells
                this.canvas = document.createElement('canvas');
                this.gl = this.canvas.getContext('webgl2');
                
                if (!this.gl) {
                    console.warn('WebGL2 not available, falling back to CPU');
                    this.useCPU = true;
                    this.state = new Float32Array(n * 4);
                    this._initialize_golden();
                    return;
                }
                
                this.useCPU = false;
                this.textureSize = Math.ceil(Math.sqrt(n));
                
                // Create textures for state (p, q, scale, curvature)
                this.stateTexture = this.createTexture();
                this.outputTexture = this.createTexture();
                
                // Create framebuffer
                this.framebuffer = this.gl.createFramebuffer();
                
                // Compile shader
                this.program = this.createShaderProgram();
                
                // Initialize state
                this.state = new Float32Array(n * 4);
                this._initialize_golden();
                this.uploadState();
            }
            
            createTexture() {
                const gl = this.gl;
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize, this.textureSize, 
                             0, gl.RGBA, gl.FLOAT, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                return texture;
            }
            
            createShaderProgram() {
                const gl = this.gl;
                
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `#version 300 es
                    in vec2 position;
                    out vec2 texCoord;
                    void main() {
                        texCoord = position * 0.5 + 0.5;
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `);
                gl.compileShader(vertexShader);
                
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, `#version 300 es
                    precision highp float;
                    in vec2 texCoord;
                    out vec4 outColor;
                    uniform sampler2D stateTexture;
                    uniform float phi;
                    
                    void main() {
                        vec4 state = texture(stateTexture, texCoord);
                        float p = state.x;
                        float q = state.y;
                        
                        // Hamiltonian evolution
                        float dp = -sin(q) * 0.05 - p * 0.02;
                        float dq = cos(p) * 0.05 - q * 0.02;
                        
                        p += dp;
                        q += dq;
                        
                        // Decay
                        p *= 0.98;
                        q *= 0.98;
                        
                        outColor = vec4(p, q, state.z, state.w);
                    }
                `);
                gl.compileShader(fragmentShader);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                return program;
            }
            
            _initialize_golden() {
                const phi = (1 + Math.sqrt(5)) / 2;
                const phi0 = 2 * Math.PI / phi;
                for (let i = 0; i < this.n; i++) {
                    this.state[i * 4] = Math.sin(phi0 * (i + 1)) * 0.1;
                    this.state[i * 4 + 1] = Math.cos(phi0 * (i + 1)) * 0.1;
                    this.state[i * 4 + 2] = 1.0;
                    this.state[i * 4 + 3] = 0.0;
                }
            }
            
            uploadState() {
                if (this.useCPU) return;
                const gl = this.gl;
                gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize, this.textureSize,
                             0, gl.RGBA, gl.FLOAT, this.state);
            }
            
            evolve() {
                if (this.useCPU) {
                    // CPU fallback
                    const phi = (1 + Math.sqrt(5)) / 2;
                    for (let i = 0; i < this.n; i++) {
                        const p = this.state[i * 4];
                        const q = this.state[i * 4 + 1];
                        const dp = -Math.sin(q) * 0.05 - p * 0.02;
                        const dq = Math.cos(p) * 0.05 - q * 0.02;
                        this.state[i * 4] = (p + dp) * 0.98;
                        this.state[i * 4 + 1] = (q + dq) * 0.98;
                    }
                    return;
                }
                
                // GPU evolution
                const gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
                                       gl.TEXTURE_2D, this.outputTexture, 0);
                
                gl.viewport(0, 0, this.textureSize, this.textureSize);
                gl.useProgram(this.program);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
                gl.uniform1i(gl.getUniformLocation(this.program, 'stateTexture'), 0);
                
                // Draw quad
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    -1, -1,  1, -1,  -1, 1,  1, 1
                ]), gl.STATIC_DRAW);
                
                const posLoc = gl.getAttribLocation(this.program, 'position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                // Swap textures
                [this.stateTexture, this.outputTexture] = [this.outputTexture, this.stateTexture];
            }
            
            downloadState() {
                if (this.useCPU) return;
                const gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                                       gl.TEXTURE_2D, this.stateTexture, 0);
                gl.readPixels(0, 0, this.textureSize, this.textureSize, gl.RGBA, gl.FLOAT, this.state);
            }
        }
        
        // ============================================================================
        // 100K CELL FIL NEURAL AGENT
        // ============================================================================
        
        class MassiveFILAgent {
            constructor() {
                this.active = false;
                this.currentFitness = 0;
                this.bestFitness = 0;
                this.decisions = 0;
                this.currentStrategy = 'EXPLORE';
                
                // 100,000 cell GPU-accelerated brain
                this.brain = new GPUFILManifold(100000);
                
                // Sensory/Motor architecture
                this.sensory = [0, 4096];      // 4096 sensory neurons
                this.hidden1 = [4096, 28672];  // 24576 hidden neurons
                this.hidden2 = [28672, 53248]; // 24576 hidden neurons  
                this.hidden3 = [53248, 77824]; // 24576 hidden neurons
                this.motor = [77824, 100000];  // 22176 motor neurons
                
                // Weights for massive compute
                this.weights = this.initWeights();
                
                // SCORING & PROGRESSION
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('mobius_high_score') || '0');
                this.totalMates = 0;
                this.totalFood = 0;
                this.totalDNA = 0;
                this.generationsReached = 0;
                this.longestLife = 0;
                this.totalDistance = 0;
                this.achievementsUnlocked = new Set();
                
                console.log('100K FIL Brain initialized!', this.brain.useCPU ? 'CPU' : 'GPU');
            }
            
            initWeights() {
                // Efficient sparse weight representation
                const phi = (1 + Math.sqrt(5)) / 2;
                return {
                    phi: phi,
                    scale: 0.01
                };
            }
            
            // Compute weight on-the-fly using golden ratio function
            getWeight(i, j, phi) {
                return Math.sin(i * phi + j / phi) * 0.01;
            }
            
            toggle() {
                this.active = !this.active;
                return this.active;
            }
            
            encodeSensory(game) {
                const sensory = new Float32Array(4096);
                
                // CRITICAL: High-res directional encoding
                const visualRes = 2048;
                
                // THREATS - SUPER HIGH SALIENCE
                game.predators.forEach(pred => {
                    const dq = pred.q - game.player.q;
                    const dr = pred.r - game.player.r;
                    const dist = Math.abs(dq) + Math.abs(dr); // Manhattan distance for hex grid
                    const angle = Math.atan2(dr, dq);
                    
                    // MASSIVE threat signal - scales with proximity
                    const threat = Math.max(0, 12.0 * (1 - dist / 10));
                    
                    if (threat > 0.1) {
                        const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                        // Wide activation so it's hard to miss
                        for (let offset = -30; offset <= 30; offset++) {
                            const i = (idx + offset + visualRes) % visualRes;
                            sensory[i] = Math.max(sensory[i], threat * Math.exp(-offset * offset / 80));
                        }
                    }
                });
                
                // Food - HIGH SALIENCE, especially when hungry
                const hungerBoost = game.player.energy < 50 ? 2.0 : 1.0;
                game.foodSources.forEach(food => {
                    if (food.type === 'DNA' && game.player.genome.slots[food.gene]) return;
                    if (food.respawnTimer > 0) return;
                    
                    const dq = food.q - game.player.q;
                    const dr = food.r - game.player.r;
                    const dist = Math.sqrt(dq * dq + dr * dr);
                    const angle = Math.atan2(dr, dq);
                    
                    const baseSalience = food.type === 'ENERGY' ? 6.0 : 4.0;
                    const foodSignal = Math.max(0, baseSalience * hungerBoost * (1 - dist / 20));
                    
                    const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                    for (let offset = -15; offset <= 15; offset++) {
                        const i = (idx + offset + visualRes) % visualRes;
                        sensory[i] += foodSignal * Math.exp(-offset * offset / 30) * 0.5;
                    }
                });
                
                // Mates - STRONG DRIVE for adults
                if (game.player.stage === 'ADULT' && !game.brood) {
                    game.npcFlies.forEach(npc => {
                        const dq = npc.q - game.player.q;
                        const dr = npc.r - game.player.r;
                        const dist = Math.sqrt(dq * dq + dr * dr);
                        const angle = Math.atan2(dr, dq);
                        
                        const mateSignal = Math.max(0, 7.0 * (1 - dist / 18));
                        
                        const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                        for (let offset = -18; offset <= 18; offset++) {
                            const i = (idx + offset + visualRes) % visualRes;
                            sensory[i] += mateSignal * Math.exp(-offset * offset / 35) * 0.6;
                        }
                    });
                }
                
                // Internal state - BOOSTED DRIVES
                sensory[2048] = game.player.stage === 'LARVA' ? 5.0 : 0.0;
                sensory[2049] = game.player.stage === 'PUPA' ? 5.0 : 0.0;
                sensory[2050] = game.player.stage === 'ADULT' ? 5.0 : 0.0;
                sensory[2051] = (game.player.age / game.player.maxAge) * 4.0;
                sensory[2052] = (game.player.energy / 100) * 3.0;
                sensory[2053] = game.brood ? 10.0 : 0.0; // URGENT: select offspring!
                
                const onFood = game.foodSources.some(f => f.q === game.player.q && f.r === game.player.r && f.respawnTimer === 0);
                sensory[2054] = onFood ? 8.0 : 0.0; // STRONG: eat now!
                
                const nearMate = game.npcFlies.some(n => Math.abs(n.q - game.player.q) + Math.abs(n.r - game.player.r) <= 2);
                sensory[2055] = (nearMate && game.player.stage === 'ADULT' && !game.brood) ? 9.0 : 0.0; // STRONG: mate now!
                
                // Energy urgency - CRITICAL when low
                if (game.player.energy < 40) {
                    sensory[2056] = 12.0; // STARVING!
                } else if (game.player.energy < 60) {
                    sensory[2056] = 6.0; // Hungry
                } else {
                    sensory[2056] = 0.0;
                }
                
                // Mating urge for adults without brood - VERY STRONG
                if (game.player.stage === 'ADULT' && !game.brood) {
                    sensory[2057] = 12.0; // VERY STRONG breeding drive
                }
                
                return sensory;
            }
            
            forward(sensory, game) {
                // MASSIVE GPU COMPUTATION
                
                // Layer 1: 4096 ‚Üí 24576 (sparse sampling)
                const h1 = new Float32Array(24576);
                for (let i = 0; i < 4096; i++) {
                    if (sensory[i] > 0.01) {
                        // Sample 64 connections per input neuron instead of all 24576
                        for (let k = 0; k < 64; k++) {
                            const j = (i * 97 + k * 379) % 24576; // Pseudo-random but deterministic
                            h1[j] += sensory[i] * this.getWeight(i, j, this.weights.phi);
                        }
                    }
                }
                
                // Inject into manifold + evolve (GPU work!)
                for (let i = 0; i < 24576; i++) {
                    this.brain.state[(4096 + i) * 4] = Math.tanh(h1[i]);
                }
                this.brain.evolve();
                this.brain.evolve();
                this.brain.evolve(); // Triple evolve for more GPU work
                
                // Layer 2: 24576 ‚Üí 24576 (highly sparse)
                const h2 = new Float32Array(24576);
                for (let i = 0; i < 24576; i++) {
                    const val = this.brain.state[(4096 + i) * 4];
                    if (Math.abs(val) > 0.01) {
                        // Only 32 connections per neuron
                        for (let k = 0; k < 32; k++) {
                            const j = (i * 73 + k * 211) % 24576;
                            h2[j] += val * this.getWeight(i, j, this.weights.phi);
                        }
                    }
                }
                
                for (let i = 0; i < 24576; i++) {
                    this.brain.state[(28672 + i) * 4] = Math.tanh(h2[i]);
                }
                this.brain.evolve();
                this.brain.evolve();
                
                // Motor output from brain state
                const motor = new Float32Array(22176);
                
                // Read movement preferences from brain
                for (let i = 0; i < 8192; i++) {
                    motor[i] = this.brain.state[(77824 + i) * 4];
                }
                
                // DIRECT BEHAVIORAL RESPONSES FROM SENSORY STATE
                // These bypass the weak sparse connections and respond immediately
                
                // Feed response - DIRECTLY from sensory
                const onFood = sensory[2054] > 5.0; // Direct check
                motor[20000] = onFood ? 20.0 : 0.0; // VERY HIGH
                
                // Mate response - DIRECTLY from sensory with STRONG breeding drive contribution
                const nearMate = sensory[2055] > 5.0; // Direct check
                const breedingDrive = sensory[2057] * 2.5; // Amplify breeding drive!
                motor[20500] = nearMate ? 25.0 : breedingDrive; // VERY HIGH when near, strong drive otherwise
                
                // Offspring selection - DIRECTLY from sensory
                motor[21000] = sensory[2053]; // Pass through directly (10.0 when brood exists)
                
                // Hunger modulation - boost food-seeking in motor layer
                if (sensory[2056] > 8.0) { // Starving
                    // Boost motor responses toward food signals
                    for (let i = 0; i < 2048; i++) {
                        if (sensory[i] > 2.0) { // Food signal
                            const motorIdx = (i * 4) % 8192;
                            motor[motorIdx] += sensory[i] * 3.0; // STRONG boost
                        }
                    }
                }
                
                return motor;
            }
            
            decide(game) {
                if (!this.active) return null;
                this.decisions++;
                
                const sensory = this.encodeSensory(game);
                
                // Calculate max threat
                let maxThreat = 0;
                let threatAngle = null;
                for (let i = 0; i < 2048; i++) {
                    if (sensory[i] > maxThreat) {
                        maxThreat = sensory[i];
                        threatAngle = (i / 2048) * 2 * Math.PI - Math.PI;
                    }
                }
                
                // Check if we're on important business
                const onMission = (game.player.stage === 'ADULT' && !game.brood) || sensory[2056] > 8.0;
                const fleeThreshold = onMission ? 6.0 : 4.0; // Higher threshold when on mission
                
                // If in IMMEDIATE DANGER, flee
                if (maxThreat > fleeThreshold && threatAngle !== null) {
                    const escapeAngle = threatAngle + Math.PI;
                    const normalizedAngle = ((escapeAngle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                    const directionIndex = Math.round((normalizedAngle / (Math.PI / 2))) % 4;
                    const dirs = ['RIGHT', 'DOWN', 'LEFT', 'UP'];
                    
                    this.currentStrategy = 'FLEE_' + dirs[directionIndex];
                    console.log(`FLEEING! Threat=${maxThreat.toFixed(2)}, Angle=${(threatAngle*180/Math.PI).toFixed(0)}¬∞, Escape=${dirs[directionIndex]}`);
                    return { type: 'MOVE', direction: dirs[directionIndex] };
                }
                
                const motor = this.forward(sensory, game);
                
                // Check for undefined refs
                if (!game.foodSources || !game.player) return null;
                
                // Decode behaviors - REORDERED PRIORITIES
                
                // 1. Select offspring (highest priority when available)
                if (motor[21000] > 8.0 && game.brood) {
                    this.currentStrategy = 'SELECT';
                    console.log('SELECTING OFFSPRING!');
                    return { type: 'SELECT_OFFSPRING', index: 0 };
                }
                
                // 2. Feed if STANDING ON FOOD - immediate action
                if (motor[20000] > 12.0) {
                    const food = game.foodSources.find(f => f.q === game.player.q && f.r === game.player.r && f.respawnTimer === 0);
                    if (food) {
                        this.currentStrategy = 'FEED';
                        console.log('FEEDING!');
                        return { type: 'FEED' };
                    }
                }
                
                // 3. Mate if NEXT TO PARTNER - immediate action
                if (motor[20500] > 20.0 && game.player.stage === 'ADULT' && !game.brood) {
                    const near = game.npcFlies.find(n => Math.abs(n.q - game.player.q) + Math.abs(n.r - game.player.r) <= 2);
                    if (near) {
                        this.currentStrategy = 'MATE';
                        console.log('MATING!');
                        return { type: 'MATE' };
                    }
                }
                
                // 4. ACTIVE MATE-SEEKING - HIGH PRIORITY for adults (before food seeking!)
                if (game.player.stage === 'ADULT' && !game.brood && motor[20500] > 15.0) {
                    const nearest = game.npcFlies.reduce((closest, npc) => {
                        const dist = Math.abs(npc.q - game.player.q) + Math.abs(npc.r - game.player.r);
                        return dist < closest.dist ? { npc, dist } : closest;
                    }, { dist: Infinity, npc: null });
                    
                    if (nearest.npc && nearest.dist < 15) { // Increased from 10 to 15
                        const dq = nearest.npc.q - game.player.q;
                        const dr = nearest.npc.r - game.player.r;
                        let dir;
                        if (Math.abs(dq) > Math.abs(dr)) {
                            dir = dq > 0 ? 'RIGHT' : 'LEFT';
                        } else {
                            dir = dr > 0 ? 'DOWN' : 'UP';
                        }
                        this.currentStrategy = 'SEEK_MATE';
                        console.log(`Seeking mate at (${nearest.npc.q},${nearest.npc.r}), dist=${nearest.dist}`);
                        return { type: 'MOVE', direction: dir };
                    }
                }
                
                // 5. ACTIVE FOOD-SEEKING - when hungry
                if (sensory[2056] > 5.0 || game.player.energy < 40) {
                    const foodTargets = game.foodSources.filter(f => {
                        if (f.respawnTimer > 0) return false;
                        if (f.type === 'DNA' && game.player.genome.slots[f.gene]) return false;
                        return true;
                    });
                    
                    if (foodTargets.length > 0) {
                        const nearest = foodTargets.reduce((closest, food) => {
                            const dist = Math.abs(food.q - game.player.q) + Math.abs(food.r - game.player.r);
                            return dist < closest.dist ? { food, dist } : closest;
                        }, { dist: Infinity, food: null });
                        
                        if (nearest.food && nearest.dist < 15) { // Increased from 12 to 15
                            const dq = nearest.food.q - game.player.q;
                            const dr = nearest.food.r - game.player.r;
                            let dir;
                            if (Math.abs(dq) > Math.abs(dr)) {
                                dir = dq > 0 ? 'RIGHT' : 'LEFT';
                            } else {
                                dir = dr > 0 ? 'DOWN' : 'UP';
                            }
                            this.currentStrategy = 'SEEK_FOOD';
                            console.log(`Seeking ${nearest.food.type} at (${nearest.food.q},${nearest.food.r}), dist=${nearest.dist}`);
                            return { type: 'MOVE', direction: dir };
                        }
                    }
                }
                
                // 6. Movement: find peak in first 8192 motor neurons
                let maxIdx = 0;
                let maxVal = motor[0];
                for (let i = 1; i < 8192; i++) {
                    if (motor[i] > maxVal) {
                        maxVal = motor[i];
                        maxIdx = i;
                    }
                }
                
                // EXPLORATION: If motor signal is weak, add some randomness
                if (maxVal < 0.5 && Math.random() < 0.3) {
                    const randomDir = ['RIGHT', 'DOWN', 'LEFT', 'UP'][Math.floor(Math.random() * 4)];
                    this.currentStrategy = 'EXPLORE';
                    console.log('EXPLORING:', randomDir);
                    return { type: 'MOVE', direction: randomDir };
                }
                
                // Convert to cardinal direction
                const angle = (maxIdx / 8192) * 2 * Math.PI;
                const directionIndex = Math.round((angle / (Math.PI / 2))) % 4;
                const dirs = ['RIGHT', 'DOWN', 'LEFT', 'UP'];
                
                this.currentStrategy = 'MOVE_' + dirs[directionIndex];
                return { type: 'MOVE', direction: dirs[directionIndex] };
            }
            
            reward(game) {
                let r = 0;
                r += game.player.energy * 2; // Energy critical
                r += Object.keys(game.player.genome.slots).filter(k => game.player.genome.slots[k]).length * 30;
                r += game.player.stage === 'ADULT' ? 60 : 0;
                
                const minPredDist = Math.min(...game.predators.map(p => 
                    Math.abs(p.q - game.player.q) + Math.abs(p.r - game.player.r)
                ));
                r += minPredDist > 4 ? 40 : (minPredDist < 2 ? -100 : -20);
                
                this.currentFitness = r;
                if (r > this.bestFitness) this.bestFitness = r;
            }
            
            // SCORING SYSTEM
            addScore(points, reason) {
                this.score += points;
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('mobius_high_score', this.highScore.toString());
                }
                console.log(`+${points} pts: ${reason} (Total: ${this.score})`);
                this.checkAchievements();
            }
            
            onMating() {
                this.totalMates++;
                this.addScore(500, 'MATING SUCCESS');
                this.checkAchievements();
            }
            
            onFeeding(type) {
                this.totalFood++;
                if (type === 'DNA') {
                    this.totalDNA++;
                    this.addScore(200, 'DNA ACQUIRED');
                } else {
                    this.addScore(50, 'ENERGY FOOD');
                }
            }
            
            onGeneration(gen) {
                this.generationsReached = Math.max(this.generationsReached, gen);
                this.addScore(gen * 100, `GEN ${gen} REACHED`);
            }
            
            onSurvival(age, stage) {
                const points = stage === 'ADULT' ? 5 : 2;
                this.addScore(points, 'SURVIVAL');
                this.longestLife = Math.max(this.longestLife, age);
            }
            
            onMovement(dist) {
                this.totalDistance += dist;
                if (this.totalDistance % 50 === 0) {
                    this.addScore(10, 'EXPLORATION');
                }
            }
            
            checkAchievements() {
                const achievements = [
                    { id: 'first_mate', check: () => this.totalMates >= 1, msg: 'üéâ First Mate!' },
                    { id: 'breeder', check: () => this.totalMates >= 5, msg: 'üíï Breeder - 5 Mates!' },
                    { id: 'prolific', check: () => this.totalMates >= 10, msg: 'üëë Prolific - 10 Mates!' },
                    { id: 'first_gen', check: () => this.generationsReached >= 2, msg: 'üß¨ Generation 2!' },
                    { id: 'dynasty', check: () => this.generationsReached >= 5, msg: 'üèÜ Dynasty - Gen 5!' },
                    { id: 'collector', check: () => this.totalDNA >= 3, msg: 'üß™ Collector - 3 DNA!' },
                    { id: 'complete', check: () => this.totalDNA >= 4, msg: 'üíé Complete Genome!' },
                    { id: 'explorer', check: () => this.totalDistance >= 100, msg: 'üó∫Ô∏è Explorer - 100 tiles!' },
                    { id: 'survivor', check: () => this.longestLife >= 200, msg: '‚è∞ Survivor - 200 turns!' },
                    { id: 'high_score', check: () => this.score >= 2000, msg: '‚≠ê Score 2000!' },
                ];
                
                achievements.forEach(ach => {
                    if (!this.achievementsUnlocked.has(ach.id) && ach.check()) {
                        this.achievementsUnlocked.add(ach.id);
                        console.log(`üèÜ ACHIEVEMENT: ${ach.msg}`);
                        this.addScore(250, 'ACHIEVEMENT');
                        // Store reference to game scene for notification
                        if (window.gameScene) {
                            window.gameScene.showAchievementNotification(ach.msg);
                        }
                    }
                });
            }
        }
        
        // Core systems (abbreviated - same as before)
        const LOCI = {
            Notch: { class: 'Core', effects: { viability: 15 }, instability: 0 },
            Egfr: { class: 'Core', effects: { viability: 12 }, instability: 0 },
            hh: { class: 'Core', effects: { viability: 10 }, instability: 1 },
            wg: { class: 'Core', effects: { viability: 10 }, instability: 1 },
            vg: { class: 'Sensorimotor', effects: { flight: 8 }, instability: 1 },
            Hsp70: { class: 'Metabolic', effects: { heat_tol: 12 }, instability: 1 },
            InR: { class: 'Metabolic', effects: { energy: 8 }, instability: 2 },
            Orco: { class: 'Sensorimotor', effects: { olfaction: 10 }, instability: 1 }
        };
        
        class HexGrid {
            constructor(hexSize) {
                this.hexSize = hexSize;
            }
            hexToPixel(q, r) {
                const x = this.hexSize * (3/2 * q);
                const y = this.hexSize * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
                return { x, y };
            }
            drawHexagon(graphics, x, y, size, color, alpha = 1) {
                graphics.fillStyle(color, alpha);
                graphics.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    const hx = x + size * Math.cos(angle);
                    const hy = y + size * Math.sin(angle);
                    if (i === 0) graphics.moveTo(hx, hy);
                    else graphics.lineTo(hx, hy);
                }
                graphics.closePath();
                graphics.fillPath();
                graphics.lineStyle(2, 0x333333, 0.8);
                graphics.strokePath();
            }
        }
        
        // ============================================================================
        // GAME SCENE WITH ENERGY SYSTEM
        // ============================================================================
        
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                this.agent = new MassiveFILAgent();
            }
            
            create() {
                this.cameras.main.setBackgroundColor('#1a1a1a');
                this.hexSize = 28;
                this.hexGrid = new HexGrid(this.hexSize);
                this.tiles = [];
                this.foodSources = [];
                this.predators = [];
                this.npcFlies = [];
                this.generation = 1;
                
                // Make this globally accessible for achievement notifications
                window.gameScene = this;
                
                this.generateWorld();
                
                this.hexGraphics = this.add.graphics();
                this.foodGraphics = this.add.graphics();
                this.predatorGraphics = this.add.graphics();
                this.npcGraphics = this.add.graphics();
                
                this.drawWorld();
                
                this.player = {
                    q: 0, r: 0, stage: 'LARVA', turn: 0, age: 0, maxAge: 30,
                    energy: 100,
                    genome: {
                        slots: { Notch: true, Egfr: true, hh: true, wg: true },
                        instability: 3
                    },
                    inventory: [], alive: true
                };
                
                this.playerSprite = this.add.circle(0, 0, 10, 0xFF6B6B).setDepth(100);
                this.updatePlayerSprite();
                
                this.cameras.main.startFollow(this.playerSprite, true, 0.1, 0.1);
                this.cameras.main.setZoom(1.2);
                
                this.setupInput();
                this.updateAllUI();
                
                this.brood = null;
                this.eventLog = [];
                
                this.log('100K GPU FIL Brain - ONLINE!', '#00ff00');
                this.log('Press A to activate neural net', '#ff00ff');
                
                // AI tick
                this.time.addEvent({
                    delay: 200,
                    callback: () => {
                        if (!this.agent.active || !this.player.alive) return;
                        const action = this.agent.decide(this);
                        if (action) this.executeAction(action);
                    },
                    loop: true
                });
                
                // Energy drain - slower now (every 2 seconds)
                this.time.addEvent({
                    delay: 2000,
                    callback: () => {
                        if (this.player.alive) {
                            this.player.energy = Math.max(0, this.player.energy - 1);
                            if (this.player.energy <= 0) this.die('starvation');
                            this.updateAllUI();
                        }
                    },
                    loop: true
                });
                
                // NPC/Pred updates
                this.time.addEvent({
                    delay: 1000,
                    callback: () => {
                        this.updateNPCs();
                        this.updatePredators();
                    },
                    loop: true
                });
            }
            
            generateWorld() {
                // Tiles
                for (let q = -15; q <= 15; q++) {
                    for (let r = -10; r <= 10; r++) {
                        const pos = this.hexGrid.hexToPixel(q, r);
                        this.tiles.push({ q, r, x: pos.x, y: pos.y });
                    }
                }
                
                // FOOD: Mix of DNA and ENERGY - MORE FOOD!
                const foodDefs = [
                    // DNA food (brown/orange)
                    { q: 3, r: 2, type: 'DNA', gene: 'vg', color: 0x8B4513 },
                    { q: -4, r: 3, type: 'DNA', gene: 'Hsp70', color: 0xFFA500 },
                    { q: 5, r: -2, type: 'DNA', gene: 'InR', color: 0xD2B48C },
                    { q: -2, r: -4, type: 'DNA', gene: 'Orco', color: 0xFFFF99 },
                    
                    // ENERGY food (green circles) - MORE SCATTERED AROUND!
                    { q: 7, r: 1, type: 'ENERGY', color: 0x00ff00 },
                    { q: -6, r: -1, type: 'ENERGY', color: 0x00ff00 },
                    { q: 2, r: 5, type: 'ENERGY', color: 0x00ff00 },
                    { q: -8, r: 4, type: 'ENERGY', color: 0x00ff00 },
                    { q: 10, r: -4, type: 'ENERGY', color: 0x00ff00 },
                    { q: -3, r: 7, type: 'ENERGY', color: 0x00ff00 },
                    { q: 12, r: 2, type: 'ENERGY', color: 0x00ff00 },
                    { q: -10, r: -5, type: 'ENERGY', color: 0x00ff00 },
                    { q: 0, r: -8, type: 'ENERGY', color: 0x00ff00 },
                    { q: 8, r: 6, type: 'ENERGY', color: 0x00ff00 },
                    { q: -5, r: -7, type: 'ENERGY', color: 0x00ff00 },
                    { q: 4, r: -6, type: 'ENERGY', color: 0x00ff00 },
                ];
                
                foodDefs.forEach(f => this.foodSources.push({ ...f, respawnTimer: 0 }));
                
                // NPCs - MORE FLIES!
                [
                    { q: 4, r: 4 }, 
                    { q: -5, r: 3 }, 
                    { q: 6, r: -3 },
                    { q: -7, r: 5 },
                    { q: 9, r: -2 },
                    { q: 3, r: -5 }
                ].forEach(pos => {
                    this.npcFlies.push({
                        q: pos.q, r: pos.r, stage: 'ADULT',
                        genome: { slots: { Notch: true, Egfr: true, hh: true, wg: true }, instability: 3 }
                    });
                });
                
                // Predators - REDUCED from 2 to 1
                [{ q: -8, r: -3 }].forEach(pos => {
                    this.predators.push({
                        q: pos.q, r: pos.r, type: 'SPIDER', speed: 1, vision: 3
                    });
                });
            }
            
            drawWorld() {
                this.hexGraphics.clear();
                this.tiles.forEach(tile => {
                    this.hexGrid.drawHexagon(this.hexGraphics, tile.x, tile.y, this.hexSize, 0x2d4a2d, 0.5);
                });
                
                this.foodGraphics.clear();
                this.foodSources.forEach(food => {
                    if (food.respawnTimer > 0) return;
                    const pos = this.hexGrid.hexToPixel(food.q, food.r);
                    if (food.type === 'DNA') {
                        // Diamond for DNA
                        this.foodGraphics.fillStyle(food.color, 0.9);
                        this.foodGraphics.fillRect(pos.x - 8, pos.y - 8, 16, 16);
                        this.foodGraphics.lineStyle(2, 0xffffff, 0.8);
                        this.foodGraphics.strokeRect(pos.x - 8, pos.y - 8, 16, 16);
                    } else {
                        // Circle for energy
                        this.foodGraphics.fillStyle(food.color, 0.8);
                        this.foodGraphics.fillCircle(pos.x, pos.y, 10);
                        this.foodGraphics.lineStyle(2, 0xffffff, 0.6);
                        this.foodGraphics.strokeCircle(pos.x, pos.y, 10);
                    }
                });
            }
            
            updatePlayerSprite() {
                const pos = this.hexGrid.hexToPixel(this.player.q, this.player.r);
                this.playerSprite.setPosition(pos.x, pos.y);
                const size = this.player.stage === 'ADULT' ? 12 : (this.player.stage === 'PUPA' ? 8 : 10);
                this.playerSprite.setRadius(size);
            }
            
            setupInput() {
                this.cursors = this.input.keyboard.createCursorKeys();
                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.input.keyboard.addKey('E').on('down', () => { if (!this.agent.active) this.feed(); });
                this.input.keyboard.addKey('M').on('down', () => { if (!this.agent.active) this.mate(); });
                this.input.keyboard.addKey('A').on('down', () => this.toggleAI());
                
                for (let i = 1; i <= 9; i++) {
                    this.input.keyboard.addKey(`${i}`).on('down', () => {
                        if (this.brood && !this.agent.active) this.selectOffspring(i - 1);
                    });
                }
            }
            
            toggleAI() {
                const active = this.agent.toggle();
                document.getElementById('ai-status').innerHTML = active ? 
                    'Status: <span class="gpu">THINKING</span>' : 
                    'Status: <span class="ai">OFF</span>';
                this.log(active ? '100K GPU BRAIN ACTIVE!' : 'Neural Net OFF', '#ff00ff');
            }
            
            update() {
                if (!this.player.alive || this.agent.active) return;
                
                if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
                    this.passTurn();
                    return;
                }
                
                let direction = null;
                if (Phaser.Input.Keyboard.JustDown(this.cursors.up)) direction = 'UP';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.down)) direction = 'DOWN';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.left)) direction = 'LEFT';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.right)) direction = 'RIGHT';
                
                if (direction) this.moveInDirection(direction);
            }
            
            moveInDirection(direction) {
                let newQ = this.player.q;
                let newR = this.player.r;
                
                if (direction === 'UP') newR -= 1;
                if (direction === 'DOWN') newR += 1;
                if (direction === 'LEFT') newQ -= 1;
                if (direction === 'RIGHT') newQ += 1;
                
                // Wrap
                if (newQ < -15) newQ = 15;
                if (newQ > 15) newQ = -15;
                if (newR < -10) newR = 10;
                if (newR > 10) newR = -10;
                
                this.player.q = newQ;
                this.player.r = newR;
                this.player.turn++;
                this.player.age++;
                
                // Track movement
                this.agent.onMovement(1);
                
                // Survival bonus every 10 turns
                if (this.player.age % 10 === 0) {
                    this.agent.onSurvival(this.player.age, this.player.stage);
                }
                
                this.checkLifecycleAdvancement();
                this.checkPredators();
                this.updatePlayerSprite();
                this.updateAllUI();
                this.drawWorld();
            }
            
            passTurn() {
                this.player.turn++;
                this.player.age++;
                this.checkLifecycleAdvancement();
                this.updateAllUI();
            }
            
            checkLifecycleAdvancement() {
                if (this.player.age >= this.player.maxAge) {
                    const stages = ['LARVA', 'PUPA', 'ADULT'];
                    const idx = stages.indexOf(this.player.stage);
                    if (idx < stages.length - 1) {
                        this.player.stage = stages[idx + 1];
                        this.player.age = 0;
                        this.player.maxAge = this.player.stage === 'ADULT' ? 300 : 30; // Adults live 60 seconds!
                        this.log(`‚üπ ${this.player.stage}`, '#00ffff');
                        this.updatePlayerSprite();
                    } else {
                        this.die('old age');
                    }
                }
            }
            
            feed() {
                const food = this.foodSources.find(f => f.q === this.player.q && f.r === this.player.r && f.respawnTimer === 0);
                if (!food) return;
                
                if (food.type === 'ENERGY') {
                    this.player.energy = Math.min(100, this.player.energy + 30);
                    this.log('‚úì Energy +30', '#00ff00');
                    this.createParticleEffect(this.player.q, this.player.r, 0x00ff00, 10);
                    this.showScorePopup(this.player.q, this.player.r, '+50', 0xffff00);
                    this.agent.onFeeding('ENERGY');
                } else {
                    if (!this.player.genome.slots[food.gene]) {
                        this.player.genome.slots[food.gene] = true;
                        this.player.genome.instability += LOCI[food.gene].instability;
                        this.log(`‚úì DNA: ${food.gene}`, '#00ff00');
                        this.createParticleEffect(this.player.q, this.player.r, food.color, 15);
                        this.showScorePopup(this.player.q, this.player.r, '+200', 0x00ffff);
                        this.agent.onFeeding('DNA');
                    }
                    this.player.energy = Math.min(100, this.player.energy + 10);
                }
                
                food.respawnTimer = 10;
                this.drawWorld();
                this.updateAllUI();
            }
            
            showScorePopup(q, r, text, color) {
                const pos = this.hexGrid.hexToPixel(q, r);
                const popup = this.add.text(pos.x, pos.y - 20, text, {
                    fontSize: '20px',
                    fontFamily: 'Courier New',
                    fontStyle: 'bold',
                    color: '#' + color.toString(16).padStart(6, '0')
                });
                popup.setOrigin(0.5);
                
                this.tweens.add({
                    targets: popup,
                    y: pos.y - 60,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => popup.destroy()
                });
            }
            
            mate() {
                if (this.player.stage !== 'ADULT' || this.brood) return;
                const near = this.npcFlies.find(n => Math.abs(n.q - this.player.q) + Math.abs(n.r - this.player.r) <= 2);
                if (!near) return;
                
                this.brood = [];
                for (let i = 0; i < 8; i++) {
                    this.brood.push({
                        id: i + 1,
                        genome: JSON.parse(JSON.stringify(this.player.genome))
                    });
                }
                
                // PARTICLE EFFECT!
                this.createParticleEffect(this.player.q, this.player.r, 0xff69b4, 20);
                this.showScorePopup(this.player.q, this.player.r, '+500', 0xff69b4);
                
                this.log('‚ïê‚ïê‚ïê BROOD LAID ‚ïê‚ïê‚ïê', '#ff69b4');
                this.agent.onMating();
                document.getElementById('has-brood').style.display = 'block';
            }
            
            showAchievementNotification(msg) {
                const notification = this.add.text(450, 100, msg, {
                    fontSize: '24px',
                    fontFamily: 'Courier New',
                    fontStyle: 'bold',
                    color: '#ffff00',
                    backgroundColor: '#000000',
                    padding: { x: 20, y: 10 }
                });
                notification.setOrigin(0.5);
                notification.setScrollFactor(0);
                notification.setDepth(1000);
                
                this.tweens.add({
                    targets: notification,
                    y: 80,
                    duration: 200,
                    ease: 'Back.easeOut'
                });
                
                this.time.delayedCall(3000, () => {
                    this.tweens.add({
                        targets: notification,
                        alpha: 0,
                        y: 60,
                        duration: 500,
                        onComplete: () => notification.destroy()
                    });
                });
            }
            
            createParticleEffect(q, r, color, count) {
                const pos = this.hexGrid.hexToPixel(q, r);
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 100;
                    const particle = this.add.circle(pos.x, pos.y, 3, color);
                    particle.setAlpha(0.8);
                    
                    this.tweens.add({
                        targets: particle,
                        x: pos.x + Math.cos(angle) * speed,
                        y: pos.y + Math.sin(angle) * speed,
                        alpha: 0,
                        duration: 500 + Math.random() * 500,
                        onComplete: () => particle.destroy()
                    });
                }
            }
            
            selectOffspring(index) {
                if (!this.brood || index >= this.brood.length) return;
                
                this.generation++;
                this.agent.onGeneration(this.generation);
                
                this.player.genome = JSON.parse(JSON.stringify(this.brood[index].genome));
                this.player.stage = 'LARVA';
                this.player.age = 0;
                this.player.maxAge = 30;
                this.player.energy = 100;
                this.player.q = 0;
                this.player.r = 0;
                this.player.alive = true;
                
                this.brood = null;
                document.getElementById('has-brood').style.display = 'none';
                
                this.updatePlayerSprite();
                this.log(`‚ïê‚ïê‚ïê GEN ${this.generation} ‚ïê‚ïê‚ïê`, '#00ff00');
                this.updateAllUI();
            }
            
            checkPredators() {
                this.predators.forEach(pred => {
                    const dist = Math.abs(pred.q - this.player.q) + Math.abs(pred.r - this.player.r);
                    if (dist <= 1) this.die('predation');
                });
            }
            
            updatePredators() {
                this.predators.forEach(pred => {
                    if (Math.random() < 0.4) {
                        const dq = this.player.q - pred.q;
                        const dr = this.player.r - pred.r;
                        if (Math.abs(dq) > Math.abs(dr)) {
                            pred.q += Math.sign(dq);
                        } else {
                            pred.r += Math.sign(dr);
                        }
                    }
                });
                this.drawPredators();
            }
            
            drawPredators() {
                this.predatorGraphics.clear();
                this.predators.forEach(pred => {
                    const pos = this.hexGrid.hexToPixel(pred.q, pred.r);
                    this.predatorGraphics.fillStyle(0xff0000, 0.9);
                    this.predatorGraphics.beginPath();
                    this.predatorGraphics.moveTo(pos.x - 8, pos.y - 8);
                    this.predatorGraphics.lineTo(pos.x + 8, pos.y + 8);
                    this.predatorGraphics.moveTo(pos.x + 8, pos.y - 8);
                    this.predatorGraphics.lineTo(pos.x - 8, pos.y + 8);
                    this.predatorGraphics.strokePath();
                });
            }
            
            updateNPCs() {
                this.npcFlies.forEach(npc => {
                    if (Math.random() < 0.5) { // Increased from 0.3 to 0.5
                        const dirs = [{ q: 0, r: -1 }, { q: 0, r: 1 }, { q: -1, r: 0 }, { q: 1, r: 0 }];
                        const dir = dirs[Math.floor(Math.random() * dirs.length)];
                        npc.q += dir.q;
                        npc.r += dir.r;
                    }
                });
                this.drawNPCs();
            }
            
            drawNPCs() {
                this.npcGraphics.clear();
                this.npcFlies.forEach(npc => {
                    const pos = this.hexGrid.hexToPixel(npc.q, npc.r);
                    this.npcGraphics.fillStyle(0xFF69B4, 0.8);
                    this.npcGraphics.fillCircle(pos.x, pos.y, 8);
                });
            }
            
            die(cause) {
                this.player.alive = false;
                this.log(`DEATH: ${cause}`, '#ff0000');
                
                this.time.delayedCall(2000, () => {
                    this.generation++;
                    this.player.stage = 'LARVA';
                    this.player.age = 0;
                    this.player.maxAge = 30;
                    this.player.energy = 100;
                    this.player.q = 0;
                    this.player.r = 0;
                    this.player.alive = true;
                    this.updatePlayerSprite();
                    this.log(`Respawned - Gen ${this.generation}`, '#00ff00');
                    this.updateAllUI();
                });
            }
            
            executeAction(action) {
                if (action.type === 'MOVE') {
                    this.moveInDirection(action.direction);
                } else if (action.type === 'FEED') {
                    this.feed();
                    this.player.turn++;
                    this.player.age++;
                } else if (action.type === 'MATE') {
                    this.mate();
                    this.player.turn++;
                } else if (action.type === 'SELECT_OFFSPRING') {
                    this.selectOffspring(action.index);
                }
                
                this.agent.reward(this);
                this.updateAllUI();
            }
            
            updateAllUI() {
                document.getElementById('stage-display').textContent = this.player.stage;
                document.getElementById('age-display').textContent = this.player.age;
                document.getElementById('max-age-display').textContent = this.player.maxAge;
                document.getElementById('gen-display').textContent = this.generation;
                document.getElementById('energy-display').textContent = Math.floor(this.player.energy);
                
                const loci = Object.keys(this.player.genome.slots).filter(k => this.player.genome.slots[k]).length;
                document.getElementById('loci-count').textContent = loci;
                document.getElementById('instability-display').textContent = this.player.genome.instability;
                
                const dnaItems = this.player.inventory.length;
                document.getElementById('dna-count').textContent = dnaItems;
                
                document.getElementById('npc-count').textContent = this.npcFlies.length;
                
                const nearFood = this.foodSources.filter(f => {
                    const dist = Math.abs(f.q - this.player.q) + Math.abs(f.r - this.player.r);
                    return dist <= 5 && f.respawnTimer === 0;
                }).length;
                document.getElementById('food-count').textContent = nearFood;
                
                document.getElementById('ai-fitness').textContent = Math.floor(this.agent.currentFitness);
                document.getElementById('ai-strategy').textContent = this.agent.currentStrategy;
                
                // SCORING UI
                document.getElementById('score-display').textContent = this.agent.score;
                document.getElementById('high-score-display').textContent = this.agent.highScore;
                document.getElementById('gens-reached').textContent = this.agent.generationsReached;
                document.getElementById('total-mates').textContent = this.agent.totalMates;
                document.getElementById('total-food').textContent = this.agent.totalFood;
                document.getElementById('total-dna').textContent = this.agent.totalDNA;
                document.getElementById('total-dist').textContent = Math.floor(this.agent.totalDistance);
                
                // Respawn food
                this.foodSources.forEach(f => {
                    if (f.respawnTimer > 0) {
                        f.respawnTimer--;
                        if (f.respawnTimer === 0) this.drawWorld();
                    }
                });
            }
            
            log(message, color = '#ffff00') {
                console.log(message);
            }
        }
        
        const config = {
            type: Phaser.AUTO,
            width: 900,
            height: 720,
            parent: 'phaser-canvas',
            backgroundColor: '#1a1a1a',
            scene: [GameScene]
        };
        
        const game = new Phaser.Game(config);
    </script>
</body>
</html>
