<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Möbius Savanna v7.0.8 [PATCHED]</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #game-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #legend {
            width: 360px;
            background: rgba(0, 0, 0, 0.95);
            color: #00ff00;
            padding: 12px;
            overflow-y: auto;
            border-right: 2px solid #00ff00;
            font-size: 10px;
        }
        #legend h3 {
            color: #00ffff;
            margin: 8px 0 4px 0;
            font-size: 12px;
            border-bottom: 1px solid #00ffff;
        }
        #legend .key {
            margin: 3px 0;
            line-height: 1.2;
        }
        #legend .stat {
            color: #ffff00;
            font-weight: bold;
        }
        .section {
            margin-bottom: 10px;
        }
        .warning {
            color: #ff6600;
            font-weight: bold;
        }
        .danger {
            color: #ff0000;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        .quantum {
            color: #00ffff;
            font-weight: bold;
        }
        .plateau {
            color: #00ff00;
            font-weight: bold;
        }
        .ai {
            color: #ff00ff;
            font-weight: bold;
        }
        .mate {
            color: #ff69b4;
            font-weight: bold;
        }
        .gpu {
            color: #00ff00;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .plateau-entry {
            background: rgba(0, 255, 0, 0.1);
            border-left: 2px solid #00ff00;
            padding: 3px;
            margin: 2px 0;
            font-size: 9px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="legend">
            <h2 style="color: #ff6b6b; margin: 0 0 8px 0; font-size: 15px;">MÖBIUS SAVANNA v7.0 [PATCHED]</h2>
            <div style="color: #888; font-size: 9px; margin-bottom: 10px;"><span class="gpu">100K GPU</span> | WebGL Compute | Full Fly Brain</div>
            
            <div class="section">
                <h3>CONTROLS</h3>
                <div class="key">↑↓←→ Move</div>
                <div class="key"><b>SPACE</b> Pass turn</div>
                <div class="key"><b>A</b> Toggle AI</div>
                <div class="key"><b>E</b> Pickup DNA/Food</div>
                <div class="key"><b>M</b> Mate with nearby fly</div>
                <div class="key"><b>1-9</b> Select offspring</div>
            </div>

            <div class="section">
                <h3>TOPOLOGY</h3>
                <div class="key" id="parity-status">Parity: <span class="quantum">NORMAL</span></div>
                <div class="key" id="seam-count">Seams: <span class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>PLATEAUS</h3>
                <div class="key">Found: <span id="plateau-count" class="plateau">0</span></div>
                <div id="plateau-recent" style="font-size: 8px; color: #00ff00;">
                    None yet
                </div>
            </div>

            <div class="section">
                <h3>SCORE</h3>
                <div class="key">Score: <span id="score-display" class="stat">0</span></div>
                <div class="key">High: <span id="high-score-display" class="stat">0</span></div>
                <div class="key">Gens: <span id="gens-reached" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>LIFETIME STATS</h3>
                <div class="key">Mates: <span id="total-mates" class="stat">0</span></div>
                <div class="key">Foods: <span id="total-food" class="stat">0</span></div>
                <div class="key">DNA: <span id="total-dna" class="stat">0</span></div>
                <div class="key">Dist: <span id="total-dist" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>GPU FIL BRAIN</h3>
                <div class="key" id="ai-status">Status: <span class="ai">OFF</span></div>
                <div class="key">Cells: <span class="gpu">100,000</span></div>
                <div class="key">GPU: <span class="gpu" id="gpu-status">READY</span></div>
                <div class="key">Action: <span id="ai-strategy" class="ai">--</span></div>
                <div class="key">Reward: <span id="ai-fitness" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>LIFECYCLE</h3>
                <div class="key">Stage: <span id="stage-display" class="stat">LARVA</span></div>
                <div class="key">Age: <span id="age-display" class="stat">0</span>/<span id="max-age-display">6</span></div>
                <div class="key">Gen: <span id="gen-display" class="stat">1</span></div>
                <div class="key">Energy: <span id="energy-display" class="stat">100</span>%</div>
                <div class="key" id="death-status" style="display: none;"><span class="danger">DEAD</span></div>
                <div class="key" id="can-mate" style="display: none;"><span class="mate">Can mate!</span></div>
                <div class="key" id="has-brood" style="display: none;"><span class="mate">Brood! Press 1-9</span></div>
            </div>

            <div class="section">
                <h3>GENOME</h3>
                <div class="key">Loci: <span id="loci-count" class="stat">4</span></div>
                <div class="key">Instab: <span id="instability-display" class="stat">3</span></div>
                <div class="key">DNA Items: <span id="dna-count" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>NEARBY</h3>
                <div class="key">NPCs: <span id="npc-count" class="stat">0</span></div>
                <div class="key">Food: <span id="food-count" class="stat">0</span></div>
                <div id="predator-display" style="color: #ff6600; font-size: 9px;">
                    <div class="key">Threats: None</div>
                </div>
            </div>

            <div class="section">
                <h3>SHAPES</h3>
                <div class="key">● You (red)</div>
                <div class="key">● NPCs (pink)</div>
                <div class="key">◆ DNA Food (brown/orange)</div>
                <div class="key">○ Energy Food (green)</div>
                <div class="key">✖ Predators</div>
            </div>
        </div>
        <div id="phaser-canvas"></div>
    </div>
    
    <script>
        // ============================================================================
        // GPU-ACCELERATED FIL MANIFOLD - 100K CELLS
        // ============================================================================
        
        class GPUFILManifold {
            constructor(n) {
                this.n = n; // 100,000 cells
                this.canvas = document.createElement('canvas');
                this.gl = this.canvas.getContext('webgl2');
                
                if (!this.gl) {
                    console.warn('WebGL2 not available, falling back to CPU');
                    this.useCPU = true;
                    this.state = new Float32Array(n * 4);
                    this._initialize_golden();
                    return;
                }
                
                // Check for required extensions
                const ext = this.gl.getExtension('EXT_color_buffer_float');
                if (!ext) {
                    console.warn('EXT_color_buffer_float not available, falling back to CPU');
                    this.useCPU = true;
                    this.state = new Float32Array(n * 4);
                    this._initialize_golden();
                    return;
                }
                
                this.useCPU = false;
                this.textureSize = Math.ceil(Math.sqrt(n));
                
                // Create textures for state (p, q, scale, curvature)
                this.stateTexture = this.createTexture();
                this.outputTexture = this.createTexture();
                
                // Create framebuffer
                this.framebuffer = this.gl.createFramebuffer();
                
                // Compile shader
                this.program = this.createShaderProgram();
                
                if (!this.program) {
                    console.warn('Shader compilation failed, falling back to CPU');
                    this.useCPU = true;
                    this.state = new Float32Array(n * 4);
                    this._initialize_golden();
                    return;
                }
                
                // Initialize state
                this.state = new Float32Array(n * 4);
                this._initialize_golden();
                this.uploadState();
            }
            
            createTexture() {
                const gl = this.gl;
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize, this.textureSize, 
                             0, gl.RGBA, gl.FLOAT, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                return texture;
            }
            
            createShaderProgram() {
                const gl = this.gl;
                
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `#version 300 es
                    in vec2 position;
                    out vec2 texCoord;
                    void main() {
                        texCoord = position * 0.5 + 0.5;
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `);
                gl.compileShader(vertexShader);
                
                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                    console.error('Vertex shader compile error:', gl.getShaderInfoLog(vertexShader));
                    this.useCPU = true;
                    return null;
                }
                
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, `#version 300 es
                    precision highp float;
                    in vec2 texCoord;
                    out vec4 outColor;
                    uniform sampler2D stateTexture;
                    uniform float phi;
                    
                    void main() {
                        vec4 state = texture(stateTexture, texCoord);
                        float p = state.x;
                        float q = state.y;
                        
                        // Hamiltonian evolution
                        float dp = -sin(q) * 0.05 - p * 0.02;
                        float dq = cos(p) * 0.05 - q * 0.02;
                        
                        p += dp;
                        q += dq;
                        
                        // Decay
                        p *= 0.98;
                        q *= 0.98;
                        
                        outColor = vec4(p, q, state.z, state.w);
                    }
                `);
                gl.compileShader(fragmentShader);
                
                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                    console.error('Fragment shader compile error:', gl.getShaderInfoLog(fragmentShader));
                    this.useCPU = true;
                    return null;
                }
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Shader program link error:', gl.getProgramInfoLog(program));
                    this.useCPU = true;
                    return null;
                }
                
                return program;
            }
            
            _initialize_golden() {
                const phi = (1 + Math.sqrt(5)) / 2;
                const phi0 = 2 * Math.PI / phi;
                for (let i = 0; i < this.n; i++) {
                    this.state[i * 4] = Math.sin(phi0 * (i + 1)) * 0.1;
                    this.state[i * 4 + 1] = Math.cos(phi0 * (i + 1)) * 0.1;
                    this.state[i * 4 + 2] = 1.0;
                    this.state[i * 4 + 3] = 0.0;
                }
            }
            
            uploadState() {
                if (this.useCPU) return;
                const gl = this.gl;
                gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize, this.textureSize,
                             0, gl.RGBA, gl.FLOAT, this.state);
            }
            
            evolve() {
                if (this.useCPU) {
                    // CPU fallback
                    const phi = (1 + Math.sqrt(5)) / 2;
                    for (let i = 0; i < this.n; i++) {
                        const p = this.state[i * 4];
                        const q = this.state[i * 4 + 1];
                        const dp = -Math.sin(q) * 0.05 - p * 0.02;
                        const dq = Math.cos(p) * 0.05 - q * 0.02;
                        this.state[i * 4] = (p + dp) * 0.98;
                        this.state[i * 4 + 1] = (q + dq) * 0.98;
                    }
                    return;
                }
                
                // GPU evolution
                const gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
                                       gl.TEXTURE_2D, this.outputTexture, 0);
                
                // Check framebuffer status
                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                    console.error('Framebuffer incomplete, status:', status);
                    this.useCPU = true;
                    return;
                }
                
                gl.viewport(0, 0, this.textureSize, this.textureSize);
                gl.useProgram(this.program);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
                gl.uniform1i(gl.getUniformLocation(this.program, 'stateTexture'), 0);
                
                // Draw quad
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    -1, -1,  1, -1,  -1, 1,  1, 1
                ]), gl.STATIC_DRAW);
                
                const posLoc = gl.getAttribLocation(this.program, 'position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                // Swap textures
                [this.stateTexture, this.outputTexture] = [this.outputTexture, this.stateTexture];
            }
            
            downloadState() {
                if (this.useCPU) return;
                const gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                                       gl.TEXTURE_2D, this.stateTexture, 0);
                gl.readPixels(0, 0, this.textureSize, this.textureSize, gl.RGBA, gl.FLOAT, this.state);
            }
        }
        
        // ============================================================================
        // 100K CELL FIL NEURAL AGENT
        // ============================================================================
        
        class MassiveFILAgent {
            constructor() {
                // PATCH 3: Auto-start AI
                this.active = true; // Changed from false
                this.currentFitness = 0;
                this.bestFitness = 0;
                this.decisions = 0;
                this.currentStrategy = 'EXPLORE';
                
                // 100,000 cell GPU-accelerated brain
                this.brain = new GPUFILManifold(100000);
                
                // PATCH 2: Define sensory band structure
                this.BANDS = {
                    DIR_START: 0,        // 0..2047 directional salience (threat/food/mate)
                    DIR_LEN:   2048,
                    CHEM_START: 2560,    // 2560..3071 chemosensory (512)
                    CHEM_LEN:   512,
                    INT_START:  3584     // 3584.. for internal flags/state
                };
                
                // Sensory/Motor architecture
                this.sensory = [0, 4096];      // 4096 sensory neurons
                this.hidden1 = [4096, 28672];  // 24576 hidden neurons
                this.hidden2 = [28672, 53248]; // 24576 hidden neurons  
                this.hidden3 = [53248, 77824]; // 24576 hidden neurons
                this.motor = [77824, 100000];  // 22176 motor neurons
                
                // Weights for massive compute
                this.weights = this.initWeights();
                
                // SPATIAL WORKING MEMORY
                this.dangerMap = new Map(); // key: "q,r" -> {threat: float, age: int}
                this.visitedTiles = new Map(); // key: "q,r" -> {count: int, lastVisit: int}
                this.boundaryMemory = new Map(); // key: "q,r" -> tick when hit
                this.tick = 0; // Decision counter for memory decay
                
                // STUCK DETECTION
                this.lastAction = null;
                this.actionRepeatCount = 0;
                this.recentFlee = null; // Track last flee direction to prevent oscillation
                
                // SCORING & PROGRESSION
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('mobius_high_score') || '0');
                this.totalMates = 0;
                this.totalFood = 0;
                this.totalDNA = 0;
                this.generationsReached = 0;
                this.longestLife = 0;
                this.totalDistance = 0;
                this.achievementsUnlocked = new Set();
                
                console.log('100K FIL Brain initialized!', this.brain.useCPU ? 'CPU' : 'GPU');
            }
            
            initWeights() {
                // Efficient sparse weight representation
                const phi = (1 + Math.sqrt(5)) / 2;
                return {
                    phi: phi,
                    scale: 0.01
                };
            }
            
            // Compute weight on-the-fly using golden ratio function
            getWeight(i, j, phi) {
                return Math.sin(i * phi + j / phi) * 0.01;
            }
            
            toggle() {
                this.active = !this.active;
                return this.active;
            }
            
            updateSpatialMemory(game) {
                // Decay old memories
                for (const [key, mem] of this.dangerMap.entries()) {
                    mem.age++;
                    mem.threat *= 0.95; // Decay threat over time
                    if (mem.threat < 0.1 || mem.age > 50) {
                        this.dangerMap.delete(key);
                    }
                }
                
                // Record current predator positions
                game.predators.forEach(pred => {
                    const key = `${pred.q},${pred.r}`;
                    const threat = pred.speed === 0 ? 10.0 : (pred.speed * 5.0); // Stationary = high threat memory
                    this.dangerMap.set(key, { threat, age: 0, type: pred.type });
                    
                    // Also mark adjacent tiles for stationary predators (web spiders)
                    if (pred.speed === 0) {
                        for (let dq = -2; dq <= 2; dq++) {
                            for (let dr = -2; dr <= 2; dr++) {
                                if (dq === 0 && dr === 0) continue;
                                const adjKey = `${pred.q + dq},${pred.r + dr}`;
                                const adjThreat = 5.0 / (Math.abs(dq) + Math.abs(dr));
                                if (!this.dangerMap.has(adjKey) || this.dangerMap.get(adjKey).threat < adjThreat) {
                                    this.dangerMap.set(adjKey, { threat: adjThreat, age: 0, type: 'web_zone' });
                                }
                            }
                        }
                    }
                });
                
                // Track visited tiles
                const currentKey = `${game.player.q},${game.player.r}`;
                if (this.visitedTiles.has(currentKey)) {
                    const visit = this.visitedTiles.get(currentKey);
                    visit.count++;
                    visit.lastVisit = this.tick;
                } else {
                    this.visitedTiles.set(currentKey, { count: 1, lastVisit: this.tick });
                }
                
                // Limit memory size
                if (this.visitedTiles.size > 200) {
                    // Remove oldest visits
                    const sorted = Array.from(this.visitedTiles.entries())
                        .sort((a, b) => a[1].lastVisit - b[1].lastVisit);
                    for (let i = 0; i < 50; i++) {
                        this.visitedTiles.delete(sorted[i][0]);
                    }
                }
            }
            
            chooseSafeDirection(game, targetDq, targetDr) {
                // Calculate preferred direction toward target
                let preferredDir;
                if (Math.abs(targetDq) > Math.abs(targetDr)) {
                    preferredDir = targetDq > 0 ? 'RIGHT' : 'LEFT';
                } else {
                    preferredDir = targetDr > 0 ? 'DOWN' : 'UP';
                }
                
                // Check if preferred direction is dangerous
                const moves = {
                    'RIGHT': { q: 1, r: 0 },
                    'LEFT': { q: -1, r: 0 },
                    'DOWN': { q: 0, r: 1 },
                    'UP': { q: 0, r: -1 }
                };
                
                const dirScores = {};
                for (const [dir, delta] of Object.entries(moves)) {
                    const newQ = game.player.q + delta.q;
                    const newR = game.player.r + delta.r;
                    const key = `${newQ},${newR}`;
                    
                    // Start with base score
                    let score = 1.0;
                    
                    // Penalty for danger
                    if (this.dangerMap.has(key)) {
                        score -= this.dangerMap.get(key).threat;
                    }
                    
                    // Bonus for moving toward target
                    if (dir === preferredDir) {
                        score += 2.0;
                    }
                    
                    // Small penalty for repeatedly visited tiles
                    if (this.visitedTiles.has(key)) {
                        const visit = this.visitedTiles.get(key);
                        score -= visit.count * 0.1;
                    }
                    
                    dirScores[dir] = score;
                }
                
                // Pick highest scoring direction
                const best = Object.entries(dirScores).reduce((a, b) => a[1] > b[1] ? a : b);
                return best[0];
            }
            
            exploreWithMemory(game) {
                // Explore toward least-visited areas, avoiding danger
                const moves = {
                    'RIGHT': { q: 1, r: 0 },
                    'LEFT': { q: -1, r: 0 },
                    'DOWN': { q: 0, r: 1 },
                    'UP': { q: 0, r: -1 }
                };
                
                const dirScores = {};
                for (const [dir, delta] of Object.entries(moves)) {
                    const newQ = game.player.q + delta.q;
                    const newR = game.player.r + delta.r;
                    const key = `${newQ},${newR}`;
                    
                    // Start with exploration bonus
                    let score = 2.0;
                    
                    // Penalty for danger
                    if (this.dangerMap.has(key)) {
                        score -= this.dangerMap.get(key).threat * 1.5; // Stronger avoidance during exploration
                    }
                    
                    // Penalty for visited tiles
                    if (this.visitedTiles.has(key)) {
                        const visit = this.visitedTiles.get(key);
                        const recency = Math.max(0, 1.0 - (this.tick - visit.lastVisit) / 50);
                        score -= (visit.count * 0.5 + recency * 2.0);
                    } else {
                        score += 3.0; // Big bonus for unvisited tiles
                    }
                    
                    // Avoid boundaries we've tested recently
                    if (this.boundaryMemory.has(key)) {
                        score -= 1.0;
                    }
                    
                    dirScores[dir] = score;
                }
                
                // Pick highest scoring direction
                const best = Object.entries(dirScores).reduce((a, b) => a[1] > b[1] ? a : b);
                return best[0];
            }
            
            encodeSensory(game) {
                const sensory = new Float32Array(4096);
                
                // PATCH 2: Use defined bands
                const {DIR_START, DIR_LEN, CHEM_START, CHEM_LEN, INT_START} = this.BANDS;
                const visualRes = DIR_LEN; // 2048
                
                // THREATS - SUPER HIGH SALIENCE
                game.predators.forEach(pred => {
                    const dq = pred.q - game.player.q;
                    const dr = pred.r - game.player.r;
                    const dist = Math.abs(dq) + Math.abs(dr); // Manhattan distance for hex grid
                    const angle = Math.atan2(dr, dq);
                    
                    // MASSIVE threat signal - scales with proximity
                    const threat = Math.max(0, 12.0 * (1 - dist / 10));
                    
                    if (threat > 0.1) {
                        const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                        // Wide activation so it's hard to miss
                        for (let offset = -30; offset <= 30; offset++) {
                            const i = (DIR_START + ((idx + offset + visualRes) % visualRes));
                            sensory[i] = Math.max(sensory[i], threat * Math.exp(-offset * offset / 80));
                        }
                    }
                });
                
                // Food - HIGH SALIENCE, especially when hungry
                const hungerBoost = game.player.energy < 50 ? 2.0 : 1.0;
                game.foodSources.forEach(food => {
                    if (food.type === 'DNA' && game.player.genome.slots[food.gene]) return;
                    if (food.respawnTimer > 0) return;
                    
                    const dq = food.q - game.player.q;
                    const dr = food.r - game.player.r;
                    const dist = Math.sqrt(dq * dq + dr * dr);
                    const angle = Math.atan2(dr, dq);
                    
                    const baseSalience = food.type === 'ENERGY' ? 6.0 : 4.0;
                    const foodSignal = Math.max(0, baseSalience * hungerBoost * (1 - dist / 20));
                    
                    const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                    for (let offset = -15; offset <= 15; offset++) {
                        const i = (DIR_START + ((idx + offset + visualRes) % visualRes));
                        sensory[i] += foodSignal * Math.exp(-offset * offset / 30) * 0.5;
                    }
                });
                
                // CHEMOSENSORY LAYER (512 neurons - directional smell)
                for (let i = 0; i < CHEM_LEN; i++) {
                    const angle = (i / CHEM_LEN) * 2 * Math.PI;
                    const dx = Math.cos(angle);
                    const dy = Math.sin(angle);
                    
                    let smell = 0;
                    game.foodSources.forEach(food => {
                        if (food.respawnTimer > 0) return;
                        if (food.type === 'DNA' && game.player.genome.slots[food.gene]) return;
                        
                        const dq = food.q - game.player.q;
                        const dr = food.r - game.player.r;
                        const dist = Math.sqrt(dq * dq + dr * dr);
                        const dot = (dq * dx + dr * dy) / (dist + 0.01);
                        
                        if (dot > 0.7) { // In direction
                            const smellStrength = food.type === 'ENERGY' ? 0.8 : 1.2;
                            smell += Math.max(0, smellStrength * (1.0 - dist / 30) * dot);
                        }
                    });
                    
                    sensory[CHEM_START + i] = smell * hungerBoost;
                }
                
                // Mates - STRONG DRIVE for adults
                if (game.player.stage === 'ADULT' && !game.brood) {
                    game.npcFlies.forEach(npc => {
                        const dq = npc.q - game.player.q;
                        const dr = npc.r - game.player.r;
                        const dist = Math.sqrt(dq * dq + dr * dr);
                        const angle = Math.atan2(dr, dq);
                        
                        const mateSignal = Math.max(0, 7.0 * (1 - dist / 18));
                        
                        const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                        for (let offset = -18; offset <= 18; offset++) {
                            const i = (DIR_START + ((idx + offset + visualRes) % visualRes));
                            sensory[i] += mateSignal * Math.exp(-offset * offset / 35) * 0.6;
                        }
                    });
                }
                
                // Internal state - BOOSTED DRIVES (using INT_START band)
                sensory[INT_START + 0] = game.player.stage === 'LARVA' ? 5.0 : 0.0;
                sensory[INT_START + 1] = game.player.stage === 'PUPA' ? 5.0 : 0.0;
                sensory[INT_START + 2] = game.player.stage === 'ADULT' ? 5.0 : 0.0;
                sensory[INT_START + 3] = (game.player.age / game.player.maxAge) * 4.0;
                sensory[INT_START + 4] = (game.player.energy / 100) * 3.0;
                sensory[INT_START + 5] = game.brood ? 10.0 : 0.0; // URGENT: select offspring!
                
                const onFood = game.foodSources.some(f => f.q === game.player.q && f.r === game.player.r && f.respawnTimer === 0);
                sensory[INT_START + 6] = onFood ? 8.0 : 0.0; // STRONG: eat now!
                
                const nearMate = game.npcFlies.some(n => Math.abs(n.q - game.player.q) + Math.abs(n.r - game.player.r) <= 2);
                sensory[INT_START + 7] = (nearMate && game.player.stage === 'ADULT' && !game.brood) ? 9.0 : 0.0; // STRONG: mate now!
                
                // Energy urgency - CRITICAL when low
                if (game.player.energy < 40) {
                    sensory[INT_START + 8] = 12.0; // STARVING!
                } else if (game.player.energy < 60) {
                    sensory[INT_START + 8] = 6.0; // Hungry
                } else {
                    sensory[INT_START + 8] = 0.0;
                }
                
                // Mating urge for adults without brood - VERY STRONG
                if (game.player.stage === 'ADULT' && !game.brood) {
                    sensory[INT_START + 9] = 12.0; // VERY STRONG breeding drive
                }
                
                // MEMORY-BASED DANGER (spatial working memory)
                // Sample danger map in 8 cardinal/ordinal directions
                const dangerDirs = [
                    { angle: 0, dq: 1, dr: 0 },           // E
                    { angle: Math.PI/4, dq: 1, dr: -1 },  // NE
                    { angle: Math.PI/2, dq: 0, dr: -1 },  // N
                    { angle: 3*Math.PI/4, dq: -1, dr: -1 },// NW
                    { angle: Math.PI, dq: -1, dr: 0 },    // W
                    { angle: 5*Math.PI/4, dq: -1, dr: 1 },// SW
                    { angle: 3*Math.PI/2, dq: 0, dr: 1 }, // S
                    { angle: 7*Math.PI/4, dq: 1, dr: 1 }  // SE
                ];
                
                dangerDirs.forEach((dir, i) => {
                    let memDanger = 0;
                    // Check 3 tiles in this direction
                    for (let dist = 1; dist <= 3; dist++) {
                        const checkQ = game.player.q + dir.dq * dist;
                        const checkR = game.player.r + dir.dr * dist;
                        const key = `${checkQ},${checkR}`;
                        
                        if (this.dangerMap.has(key)) {
                            const danger = this.dangerMap.get(key);
                            memDanger += danger.threat / dist; // Closer = stronger signal
                        }
                    }
                    
                    // Inject remembered danger into directional layer
                    if (memDanger > 0.1) {
                        const idx = Math.floor(((dir.angle + Math.PI) / (2 * Math.PI)) * visualRes);
                        for (let offset = -10; offset <= 10; offset++) {
                            const sIdx = (DIR_START + ((idx + offset + visualRes) % visualRes));
                            sensory[sIdx] += memDanger * Math.exp(-offset * offset / 20) * 0.3;
                        }
                    }
                });
                
                return sensory;
            }
            
            forward(sensory, game) {
                // MASSIVE GPU COMPUTATION
                
                // Layer 1: 4096 → 24576 (sparse sampling)
                const h1 = new Float32Array(24576);
                for (let i = 0; i < 4096; i++) {
                    if (sensory[i] > 0.01) {
                        // Sample 64 connections per input neuron instead of all 24576
                        for (let k = 0; k < 64; k++) {
                            const j = (i * 97 + k * 379) % 24576; // Pseudo-random but deterministic
                            h1[j] += sensory[i] * this.getWeight(i, j, this.weights.phi);
                        }
                    }
                }
                
                // Inject into manifold + evolve (GPU work!)
                for (let i = 0; i < 24576; i++) {
                    this.brain.state[(4096 + i) * 4] = Math.tanh(h1[i]);
                }
                this.brain.evolve();
                this.brain.evolve();
                this.brain.evolve(); // Triple evolve for more GPU work
                
                // Layer 2: 24576 → 24576 (highly sparse)
                const h2 = new Float32Array(24576);
                for (let i = 0; i < 24576; i++) {
                    const val = this.brain.state[(4096 + i) * 4];
                    if (Math.abs(val) > 0.01) {
                        // Only 32 connections per neuron
                        for (let k = 0; k < 32; k++) {
                            const j = (i * 73 + k * 211) % 24576;
                            h2[j] += val * this.getWeight(i, j, this.weights.phi);
                        }
                    }
                }
                
                for (let i = 0; i < 24576; i++) {
                    this.brain.state[(28672 + i) * 4] = Math.tanh(h2[i]);
                }
                this.brain.evolve();
                this.brain.evolve();
                
                // PATCH 1: Sync GPU → CPU after evolves
                this.brain.downloadState();   // ensure reads reflect GPU evolution
                
                // Motor output from brain state
                const motor = new Float32Array(22176);
                
                // Read movement preferences from brain
                for (let i = 0; i < 8192; i++) {
                    motor[i] = this.brain.state[(77824 + i) * 4];
                }
                
                // PATCH 2: Use band constants for direct responses
                const ON_FOOD = sensory[this.BANDS.INT_START + 6] > 5.0;
                const NEAR_MATE = sensory[this.BANDS.INT_START + 7] > 5.0;
                const STARVING = sensory[this.BANDS.INT_START + 8] > 8.0;
                const BREED_DRIVE = sensory[this.BANDS.INT_START + 9];
                
                // DIRECT BEHAVIORAL RESPONSES FROM SENSORY STATE
                motor[20000] = ON_FOOD ? 20.0 : 0.0; // VERY HIGH
                motor[20500] = NEAR_MATE ? 25.0 : BREED_DRIVE * 2.5; // VERY HIGH when near, strong drive otherwise
                motor[21000] = sensory[this.BANDS.INT_START + 5]; // Offspring selection (10.0 when brood exists)
                
                // Hunger modulation - boost food-seeking in motor layer
                if (STARVING) {
                    // Boost motor responses toward food signals
                    for (let i = 0; i < this.BANDS.DIR_LEN; i++) {
                        const s = sensory[this.BANDS.DIR_START + i];
                        if (s > 2.0) { // Food signal
                            const motorIdx = (i * 4) % 8192;
                            motor[motorIdx] += s * 3.0; // STRONG boost
                        }
                    }
                }
                
                return motor;
            }
            
            decide(game) {
                if (!this.active) return null;
                this.decisions++;
                this.tick++;
                
                // UPDATE WORKING MEMORY
                this.updateSpatialMemory(game);
                this.cleanBoundaryMemory();
                
                // Memory diagnostics (occasional)
                if (this.tick % 50 === 0) {
                    console.log(`MEMORY: ${this.dangerMap.size} danger zones, ${this.visitedTiles.size} visited, ${this.boundaryMemory.size} boundaries`);
                }
                
                const sensory = this.encodeSensory(game);
                
                // PATCH 2: Calculate max threat using DIR band
                let maxThreat = 0;
                let threatAngle = null;
                for (let i = 0; i < this.BANDS.DIR_LEN; i++) {
                    const v = sensory[this.BANDS.DIR_START + i];
                    if (v > maxThreat) {
                        maxThreat = v;
                        threatAngle = (i / this.BANDS.DIR_LEN) * 2 * Math.PI - Math.PI;
                    }
                }
                
                // Check if we're on important business
                const onMission = (game.player.stage === 'ADULT' && !game.brood) || sensory[this.BANDS.INT_START + 8] > 8.0;
                const fleeThreshold = onMission ? 7.0 : 5.0; // Raised thresholds to reduce flee spam
                
                // ANTI-OSCILLATION: Don't flee if we just fled in the opposite direction
                if (maxThreat > fleeThreshold && threatAngle !== null) {
                    const escapeAngle = threatAngle + Math.PI;
                    const normalizedAngle = ((escapeAngle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                    const directionIndex = Math.round((normalizedAngle / (Math.PI / 2))) % 4;
                    const dirs = ['RIGHT', 'DOWN', 'LEFT', 'UP'];
                    const escapeDir = dirs[directionIndex];
                    
                    // Check if this is opposite of recent flee
                    const opposites = { 'RIGHT': 'LEFT', 'LEFT': 'RIGHT', 'UP': 'DOWN', 'DOWN': 'UP' };
                    if (this.recentFlee && this.recentFlee.dir === opposites[escapeDir] && 
                        this.tick - this.recentFlee.tick < 3) {
                        // Skip this flee - we're oscillating
                        console.log(`Skipping flee oscillation: ${escapeDir} vs recent ${this.recentFlee.dir}`);
                    } else {
                        this.currentStrategy = 'FLEE_' + escapeDir;
                        this.recentFlee = { dir: escapeDir, tick: this.tick };
                        console.log(`FLEEING! Threat=${maxThreat.toFixed(2)}, Angle=${(threatAngle*180/Math.PI).toFixed(0)}°, Escape=${escapeDir}`);
                        return { type: 'MOVE', direction: escapeDir };
                    }
                }
                
                const motor = this.forward(sensory, game);
                
                // Check for undefined refs
                if (!game.foodSources || !game.player) return null;
                
                // Decode behaviors - REORDERED PRIORITIES
                
                // 1. Select offspring (highest priority when available)
                if (motor[21000] > 8.0 && game.brood) {
                    this.currentStrategy = 'SELECT';
                    console.log('SELECTING OFFSPRING!');
                    return { type: 'SELECT_OFFSPRING', index: 0 };
                }
                
                // 2. Feed if STANDING ON FOOD - immediate action
                if (motor[20000] > 12.0) {
                    const food = game.foodSources.find(f => f.q === game.player.q && f.r === game.player.r && f.respawnTimer === 0);
                    if (food) {
                        this.currentStrategy = 'FEED';
                        console.log('FEEDING!');
                        return { type: 'FEED' };
                    }
                }
                
                // 3. Mate if NEXT TO PARTNER - immediate action
                if (motor[20500] > 20.0 && game.player.stage === 'ADULT' && !game.brood) {
                    const near = game.npcFlies.find(n => Math.abs(n.q - game.player.q) + Math.abs(n.r - game.player.r) <= 2);
                    if (near) {
                        this.currentStrategy = 'MATE';
                        console.log('MATING!');
                        return { type: 'MATE' };
                    }
                }
                
                // 4. ACTIVE MATE-SEEKING - HIGH PRIORITY for adults (before food seeking!)
                if (game.player.stage === 'ADULT' && !game.brood && motor[20500] > 15.0) {
                    const nearest = game.npcFlies.reduce((closest, npc) => {
                        const dist = Math.abs(npc.q - game.player.q) + Math.abs(npc.r - game.player.r);
                        return dist < closest.dist ? { npc, dist } : closest;
                    }, { dist: Infinity, npc: null });
                    
                    if (nearest.npc && nearest.dist < 15) { // Increased from 10 to 15
                        const dq = nearest.npc.q - game.player.q;
                        const dr = nearest.npc.r - game.player.r;
                        let dir = this.chooseSafeDirection(game, dq, dr);
                        this.currentStrategy = 'SEEK_MATE';
                        
                        // Log if we're detouring due to memory
                        const straightDir = Math.abs(dq) > Math.abs(dr) ? (dq > 0 ? 'RIGHT' : 'LEFT') : (dr > 0 ? 'DOWN' : 'UP');
                        if (dir !== straightDir) {
                            console.log(`Seeking mate at (${nearest.npc.q},${nearest.npc.r}), dist=${nearest.dist} [avoiding danger: ${straightDir}→${dir}]`);
                        } else {
                            console.log(`Seeking mate at (${nearest.npc.q},${nearest.npc.r}), dist=${nearest.dist}`);
                        }
                        return { type: 'MOVE', direction: dir };
                    }
                }
                
                // 5. ACTIVE FOOD-SEEKING - when hungry
                if (sensory[this.BANDS.INT_START + 8] > 5.0 || game.player.energy < 40) {
                    const foodTargets = game.foodSources.filter(f => {
                        if (f.respawnTimer > 0) return false;
                        if (f.type === 'DNA' && game.player.genome.slots[f.gene]) return false;
                        return true;
                    });
                    
                    if (foodTargets.length > 0) {
                        const nearest = foodTargets.reduce((closest, food) => {
                            const dist = Math.abs(food.q - game.player.q) + Math.abs(food.r - game.player.r);
                            return dist < closest.dist ? { food, dist } : closest;
                        }, { dist: Infinity, food: null });
                        
                        if (nearest.food && nearest.dist < 15) { // Increased from 12 to 15
                            const dq = nearest.food.q - game.player.q;
                            const dr = nearest.food.r - game.player.r;
                            let dir = this.chooseSafeDirection(game, dq, dr);
                            this.currentStrategy = 'SEEK_FOOD';
                            
                            // Log if we're detouring due to memory
                            const straightDir = Math.abs(dq) > Math.abs(dr) ? (dq > 0 ? 'RIGHT' : 'LEFT') : (dr > 0 ? 'DOWN' : 'UP');
                            if (dir !== straightDir) {
                                console.log(`Seeking ${nearest.food.type} at (${nearest.food.q},${nearest.food.r}), dist=${nearest.dist} [avoiding danger: ${straightDir}→${dir}]`);
                            } else {
                                console.log(`Seeking ${nearest.food.type} at (${nearest.food.q},${nearest.food.r}), dist=${nearest.dist}`);
                            }
                            return { type: 'MOVE', direction: dir };
                        }
                    }
                }
                
                // 6. Movement: find peak in first 8192 motor neurons
                let maxIdx = 0;
                let maxVal = motor[0];
                for (let i = 1; i < 8192; i++) {
                    if (motor[i] > maxVal) {
                        maxVal = motor[i];
                        maxIdx = i;
                    }
                }
                
                // EXPLORATION: If motor signal is weak, use memory-guided exploration
                if (maxVal < 0.5) {
                    const dir = this.exploreWithMemory(game);
                    this.currentStrategy = 'EXPLORE_MEM';
                    console.log('EXPLORING (memory-guided):', dir);
                    return { type: 'MOVE', direction: dir };
                }
                
                // Convert to cardinal direction
                const angle = (maxIdx / 8192) * 2 * Math.PI;
                const directionIndex = Math.round((angle / (Math.PI / 2))) % 4;
                const dirs = ['RIGHT', 'DOWN', 'LEFT', 'UP'];
                
                this.currentStrategy = 'MOVE_' + dirs[directionIndex];
                return { type: 'MOVE', direction: dirs[directionIndex] };
            }
            
            reward(game) {
                let r = 0;
                r += game.player.energy * 2; // Energy critical
                r += Object.keys(game.player.genome.slots).filter(k => game.player.genome.slots[k]).length * 30;
                r += game.player.stage === 'ADULT' ? 60 : 0;
                
                // PATCH 4: Safety guard for empty predators array
                const dists = game.predators.map(p => Math.abs(p.q - game.player.q) + Math.abs(p.r - game.player.r));
                const minPredDist = dists.length ? Math.min(...dists) : 99;
                r += minPredDist > 4 ? 40 : (minPredDist < 2 ? -100 : -20);
                
                this.currentFitness = r;
                if (r > this.bestFitness) this.bestFitness = r;
            }
            
            // SCORING SYSTEM
            addScore(points, reason) {
                this.score += points;
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('mobius_high_score', this.highScore.toString());
                }
                console.log(`+${points} pts: ${reason} (Total: ${this.score})`);
                this.checkAchievements();
            }
            
            onMating() {
                this.totalMates++;
                this.addScore(500, 'MATING SUCCESS');
                this.checkAchievements();
            }
            
            onFeeding(type) {
                this.totalFood++;
                if (type === 'DNA') {
                    this.totalDNA++;
                    this.addScore(200, 'DNA ACQUIRED');
                } else {
                    this.addScore(50, 'ENERGY FOOD');
                }
            }
            
            onGeneration(gen) {
                this.generationsReached = Math.max(this.generationsReached, gen);
                this.addScore(gen * 100, `GEN ${gen} REACHED`);
                
                // Clear spatial memory on generation change
                this.dangerMap.clear();
                this.visitedTiles.clear();
                this.boundaryMemory.clear();
                console.log('Memory cleared for new generation');
            }
            
            onBoundaryWrap(q, r) {
                // Remember we hit a boundary here
                const key = `${q},${r}`;
                this.boundaryMemory.set(key, this.tick); // Store tick, not boolean
            }
            
            cleanBoundaryMemory() {
                // Remove boundaries older than 30 ticks
                for (const [key, tickStored] of this.boundaryMemory.entries()) {
                    if (this.tick - tickStored > 30) {
                        this.boundaryMemory.delete(key);
                    }
                }
            }
            
            onSurvival(age, stage) {
                const points = stage === 'ADULT' ? 5 : 2;
                this.addScore(points, 'SURVIVAL');
                this.longestLife = Math.max(this.longestLife, age);
            }
            
            onMovement(dist) {
                this.totalDistance += dist;
                if (this.totalDistance % 50 === 0) {
                    this.addScore(10, 'EXPLORATION');
                }
            }
            
            checkAchievements() {
                const achievements = [
                    { id: 'first_mate', check: () => this.totalMates >= 1, msg: '🎉 First Mate!' },
                    { id: 'breeder', check: () => this.totalMates >= 5, msg: '💕 Breeder - 5 Mates!' },
                    { id: 'prolific', check: () => this.totalMates >= 10, msg: '👑 Prolific - 10 Mates!' },
                    { id: 'first_gen', check: () => this.generationsReached >= 2, msg: '🧬 Generation 2!' },
                    { id: 'dynasty', check: () => this.generationsReached >= 5, msg: '🏆 Dynasty - Gen 5!' },
                    { id: 'collector', check: () => this.totalDNA >= 3, msg: '🧪 Collector - 3 DNA!' },
                    { id: 'complete', check: () => this.totalDNA >= 4, msg: '💎 Complete Genome!' },
                    { id: 'explorer', check: () => this.totalDistance >= 100, msg: '🗺️ Explorer - 100 tiles!' },
                    { id: 'survivor', check: () => this.longestLife >= 200, msg: '⏰ Survivor - 200 turns!' },
                    { id: 'high_score', check: () => this.score >= 2000, msg: '⭐ Score 2000!' },
                ];
                
                achievements.forEach(ach => {
                    if (!this.achievementsUnlocked.has(ach.id) && ach.check()) {
                        this.achievementsUnlocked.add(ach.id);
                        console.log(`🏆 ACHIEVEMENT: ${ach.msg}`);
                        this.addScore(250, 'ACHIEVEMENT');
                        // Store reference to game scene for notification
                        if (window.gameScene) {
                            window.gameScene.showAchievementNotification(ach.msg);
                        }
                    }
                });
            }
        }
        
        // ============================================================================
        // EoP SYSTEM - Risk/Reward for Pickups
        // ============================================================================
        
        class EoPSystem {
            calculateCF(fly, tile, posture = 'DEFAULT') {
                let cf = tile.cf_base || 0;
                if (fly.inHeat) cf += 1;
                if (posture === 'GREEDY_SURGE') cf += 1;
                if (posture === 'SAFE_BUFFER') cf -= 1;
                return Math.max(0, cf);
            }
            
            roll(fly, item, cf, posture = 'DEFAULT') {
                const instability = fly.genome.instability || 0;
                let p_SI = 0.40, p_CS = 0.05; // Success vs Critical failure
                
                if (fly.stage === 'LARVA') p_SI += 0.10; // Larvae safer
                if (instability > 8) p_CS += 0.05; // High instability riskier
                if (cf > 2) p_CS += 0.05; // High CF riskier
                
                const roll = Math.random();
                
                if (roll < p_SI) {
                    return { outcome: 'SI', instability: -1, score: 200 }; // Success!
                }
                if (roll > 0.95) {
                    return { outcome: 'CS', instability: 2, stun: 2, score: -50 }; // Critical failure
                }
                return { outcome: 'MF', instability: 0, score: 50 }; // Mixed/neutral
            }
        }
        
        // ============================================================================
        // PLATEAU MUSEUM - Track Stable Genome Discoveries
        // ============================================================================
        
        class PlateauMuseum {
            constructor() {
                this.plateaus = [];
                this.nextPlateauId = 1;
            }
            
            checkAndSave(genome, stability, generation) {
                if (stability < 60) return null;
                
                const genomeSignature = Object.keys(genome.slots)
                    .filter(k => genome.slots[k])
                    .sort()
                    .join('|');
                
                const isNovel = !this.plateaus.some(p => p.signature === genomeSignature);
                if (!isNovel) return null;
                
                const totalGenes = Object.keys(genome.slots).filter(k => genome.slots[k]).length;
                if (totalGenes <= 4) return null; // Must have evolved beyond basics
                
                const plateau = {
                    id: this.nextPlateauId++,
                    signature: genomeSignature,
                    stability: stability,
                    generation: generation,
                    geneCount: totalGenes,
                    name: `Evolved-${totalGenes}G`,
                    timestamp: Date.now()
                };
                
                this.plateaus.push(plateau);
                return plateau;
            }
        }
        
        // ============================================================================
        // EXPANDED LOCI - 15 Genes
        // ============================================================================
        
        const LOCI = {
            // Core developmental genes
            Notch: { class: 'Core', effects: { viability: 15 }, instability: 0 },
            Egfr: { class: 'Core', effects: { viability: 12 }, instability: 0 },
            hh: { class: 'Core', effects: { viability: 10 }, instability: 1 },
            wg: { class: 'Core', effects: { viability: 10 }, instability: 1 },
            
            // Sensorimotor genes
            vg: { class: 'Sensorimotor', effects: { flight: 8 }, instability: 1 },
            sd: { class: 'Sensorimotor', effects: { flight: 6 }, instability: 1 },
            Orco: { class: 'Sensorimotor', effects: { olfaction: 10 }, instability: 1 },
            Or22a: { class: 'Sensorimotor', effects: { olfaction: 8 }, instability: 1 },
            
            // Metabolic/stress genes
            Hsp70: { class: 'Metabolic', effects: { heat_tol: 12 }, instability: 1 },
            Hsp83: { class: 'Metabolic', effects: { heat_tol: 8 }, instability: 0 },
            InR: { class: 'Metabolic', effects: { energy: 8 }, instability: 2 },
            Drip: { class: 'Metabolic', effects: { desiccation: 10 }, instability: 1 },
            Adh: { class: 'Metabolic', effects: { ferment_tol: 10 }, instability: 1 },
            Sod: { class: 'Metabolic', effects: { oxidative: 6 }, instability: 1 },
            
            // Topology sense
            Seamwise_gamma: { class: 'Topology', effects: { parity_sense: 12 }, instability: 2 }
        };
        
        class HexGrid {
            constructor(hexSize) {
                this.hexSize = hexSize;
                this.seamLine = 0; // Seam at equator (r=0)
            }
            
            hexToPixel(q, r) {
                const x = this.hexSize * (3/2 * q);
                const y = this.hexSize * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
                return { x, y };
            }
            
            crossesSeam(r_from, r_to) {
                // Crossing r=0 flips parity (Möbius twist)
                return (r_from < this.seamLine && r_to >= this.seamLine) ||
                       (r_from >= this.seamLine && r_to < this.seamLine);
            }
            
            drawHexagon(graphics, x, y, size, color, alpha = 1) {
                graphics.fillStyle(color, alpha);
                graphics.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    const hx = x + size * Math.cos(angle);
                    const hy = y + size * Math.sin(angle);
                    if (i === 0) graphics.moveTo(hx, hy);
                    else graphics.lineTo(hx, hy);
                }
                graphics.closePath();
                graphics.fillPath();
                graphics.lineStyle(2, 0x333333, 0.8);
                graphics.strokePath();
            }
        }
        
        // ============================================================================
        // GAME SCENE WITH ENERGY SYSTEM
        // ============================================================================
        
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                this.agent = new MassiveFILAgent();
                this.eopSystem = new EoPSystem(); // EoP for risk/reward pickups
                this.museum = new PlateauMuseum(); // Track stable genomes
            }
            
            create() {
                this.cameras.main.setBackgroundColor('#1a1a1a');
                this.hexSize = 28;
                this.hexGrid = new HexGrid(this.hexSize);
                this.tiles = [];
                this.foodSources = [];
                this.predators = [];
                this.npcFlies = [];
                this.generation = 1;
                
                // Make this globally accessible for achievement notifications
                window.gameScene = this;
                
                this.seamCrossings = 0; // Track topology interactions
                
                this.generateWorld();
                
                this.hexGraphics = this.add.graphics();
                this.foodGraphics = this.add.graphics();
                this.predatorGraphics = this.add.graphics();
                this.npcGraphics = this.add.graphics();
                
                this.drawWorld();
                
                this.player = {
                    q: 0, r: 0, stage: 'LARVA', turn: 0, age: 0, maxAge: 30,
                    energy: 100,
                    genome: {
                        slots: { Notch: true, Egfr: true, hh: true, wg: true },
                        instability: 3
                    },
                    inventory: [], 
                    alive: true,
                    parityFlipped: false, // Möbius topology
                    posture: 'DEFAULT', // For EoP system
                    inHeat: false, // For CF calculation
                    stunned: 0 // Stun counter
                };
                
                this.playerSprite = this.add.circle(0, 0, 10, 0xFF6B6B).setDepth(100);
                this.updatePlayerSprite();
                
                this.cameras.main.startFollow(this.playerSprite, true, 0.1, 0.1);
                this.cameras.main.setZoom(1.2);
                
                this.setupInput();
                this.updateAllUI();
                
                // PATCH 3: Update UI to reflect auto-on AI
                document.getElementById('ai-status').innerHTML = 'Status: <span class="gpu">THINKING</span>';
                
                this.brood = null;
                this.eventLog = [];
                
                this.log('100K GPU FIL Brain - ONLINE!', '#00ff00');
                this.log('AI AUTO-ENABLED! Press A to toggle', '#ff00ff');
                
                // AI tick
                this.time.addEvent({
                    delay: 200,
                    callback: () => {
                        if (!this.agent.active || !this.player.alive) return;
                        const action = this.agent.decide(this);
                        if (action) this.executeAction(action);
                    },
                    loop: true
                });
                
                // Energy drain - slower now (every 2 seconds)
                this.time.addEvent({
                    delay: 2000,
                    callback: () => {
                        if (this.player.alive) {
                            this.player.energy = Math.max(0, this.player.energy - 1);
                            if (this.player.energy <= 0) this.die('starvation');
                            this.updateAllUI();
                        }
                    },
                    loop: true
                });
                
                // NPC/Pred updates
                this.time.addEvent({
                    delay: 1000,
                    callback: () => {
                        this.updateNPCs();
                        this.updatePredators();
                    },
                    loop: true
                });
            }
            
            generateWorld() {
                // Tiles
                for (let q = -15; q <= 15; q++) {
                    for (let r = -10; r <= 10; r++) {
                        const pos = this.hexGrid.hexToPixel(q, r);
                        this.tiles.push({ q, r, x: pos.x, y: pos.y });
                    }
                }
                
                // FOOD: Mix of DNA and ENERGY - MORE FOOD with CF values!
                const foodDefs = [
                    // DNA food (brown/orange) with CF risk
                    { q: 3, r: 2, type: 'DNA', gene: 'vg', color: 0x8B4513, cf_base: 0 },
                    { q: -4, r: 3, type: 'DNA', gene: 'Hsp70', color: 0xFFA500, cf_base: 1 },
                    { q: 5, r: -2, type: 'DNA', gene: 'InR', color: 0xD2B48C, cf_base: 0 },
                    { q: -2, r: -4, type: 'DNA', gene: 'Orco', color: 0xFFFF99, cf_base: 1 },
                    { q: 8, r: 3, type: 'DNA', gene: 'Adh', color: 0xCD853F, cf_base: 0 },
                    { q: -7, r: -2, type: 'DNA', gene: 'Drip', color: 0xDEB887, cf_base: 1 },
                    
                    // ENERGY food (green circles) - pure sustenance
                    { q: 7, r: 1, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: -6, r: -1, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 2, r: 5, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: -8, r: 4, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 10, r: -4, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: -3, r: 7, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 12, r: 2, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: -10, r: -5, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 0, r: -8, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 8, r: 6, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: -5, r: -7, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                    { q: 4, r: -6, type: 'ENERGY', color: 0x00ff00, cf_base: 0 },
                ];
                
                foodDefs.forEach(f => this.foodSources.push({ ...f, respawnTimer: 0 }));
                
                // NPCs - MORE FLIES!
                [
                    { q: 4, r: 4 }, 
                    { q: -5, r: 3 }, 
                    { q: 6, r: -3 },
                    { q: -7, r: 5 },
                    { q: 9, r: -2 },
                    { q: 3, r: -5 }
                ].forEach(pos => {
                    this.npcFlies.push({
                        q: pos.q, r: pos.r, stage: 'ADULT',
                        genome: { slots: { Notch: true, Egfr: true, hh: true, wg: true }, instability: 3 }
                    });
                });
                
                // Predators - MULTIPLE TYPES!
                [
                    { q: -8, r: -3, type: 'JUMPING_SPIDER', color: 0xff0000, speed: 1, vision: 3, behavior: 'chase' },
                    { q: 10, r: 5, type: 'DRAGONFLY', color: 0xff6600, speed: 2, vision: 4, behavior: 'patrol' },
                    { q: -5, r: 8, type: 'ORB_SPIDER', color: 0xaa0000, speed: 0, vision: 2, behavior: 'web' }
                ].forEach(pos => {
                    this.predators.push({
                        q: pos.q, r: pos.r, 
                        type: pos.type,
                        color: pos.color,
                        speed: pos.speed, 
                        vision: pos.vision,
                        behavior: pos.behavior,
                        patrolDir: 1,
                        patrolCount: 0
                    });
                });
            }
            
            drawWorld() {
                this.hexGraphics.clear();
                this.tiles.forEach(tile => {
                    this.hexGrid.drawHexagon(this.hexGraphics, tile.x, tile.y, this.hexSize, 0x2d4a2d, 0.5);
                });
                
                this.foodGraphics.clear();
                this.foodSources.forEach(food => {
                    if (food.respawnTimer > 0) return;
                    const pos = this.hexGrid.hexToPixel(food.q, food.r);
                    if (food.type === 'DNA') {
                        // Diamond for DNA
                        this.foodGraphics.fillStyle(food.color, 0.9);
                        this.foodGraphics.fillRect(pos.x - 8, pos.y - 8, 16, 16);
                        this.foodGraphics.lineStyle(2, 0xffffff, 0.8);
                        this.foodGraphics.strokeRect(pos.x - 8, pos.y - 8, 16, 16);
                    } else {
                        // Circle for energy
                        this.foodGraphics.fillStyle(food.color, 0.8);
                        this.foodGraphics.fillCircle(pos.x, pos.y, 10);
                        this.foodGraphics.lineStyle(2, 0xffffff, 0.6);
                        this.foodGraphics.strokeCircle(pos.x, pos.y, 10);
                    }
                });
            }
            
            updatePlayerSprite() {
                const pos = this.hexGrid.hexToPixel(this.player.q, this.player.r);
                this.playerSprite.setPosition(pos.x, pos.y);
                const size = this.player.stage === 'ADULT' ? 12 : (this.player.stage === 'PUPA' ? 8 : 10);
                this.playerSprite.setRadius(size);
            }
            
            setupInput() {
                this.cursors = this.input.keyboard.createCursorKeys();
                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.input.keyboard.addKey('E').on('down', () => { if (!this.agent.active) this.feed(); });
                this.input.keyboard.addKey('M').on('down', () => { if (!this.agent.active) this.mate(); });
                this.input.keyboard.addKey('A').on('down', () => this.toggleAI());
                
                for (let i = 1; i <= 9; i++) {
                    this.input.keyboard.addKey(`${i}`).on('down', () => {
                        if (this.brood && !this.agent.active) this.selectOffspring(i - 1);
                    });
                }
            }
            
            toggleAI() {
                const active = this.agent.toggle();
                document.getElementById('ai-status').innerHTML = active ? 
                    'Status: <span class="gpu">THINKING</span>' : 
                    'Status: <span class="ai">OFF</span>';
                this.log(active ? '100K GPU BRAIN ACTIVE!' : 'Neural Net OFF', '#ff00ff');
            }
            
            update() {
                if (!this.player.alive || this.agent.active) return;
                
                if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
                    this.passTurn();
                    return;
                }
                
                let direction = null;
                if (Phaser.Input.Keyboard.JustDown(this.cursors.up)) direction = 'UP';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.down)) direction = 'DOWN';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.left)) direction = 'LEFT';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.right)) direction = 'RIGHT';
                
                if (direction) this.moveInDirection(direction);
            }
            
            moveInDirection(direction) {
                let newQ = this.player.q;
                let newR = this.player.r;
                
                if (direction === 'UP') newR -= 1;
                if (direction === 'DOWN') newR += 1;
                if (direction === 'LEFT') newQ -= 1;
                if (direction === 'RIGHT') newQ += 1;
                
                // Wrap HORIZONTALLY (q: -15 to 15)
                if (newQ < -15) {
                    newQ = 15;
                    this.agent.onBoundaryWrap(this.player.q, this.player.r);
                }
                if (newQ > 15) {
                    newQ = -15;
                    this.agent.onBoundaryWrap(this.player.q, this.player.r);
                }
                
                // Wrap VERTICALLY with parity flip (Möbius twist)
                if (newR < -10) {
                    newR = 10;
                    this.player.parityFlipped = !this.player.parityFlipped;
                    this.log('Möbius wrap: top→bottom', '#00ffff');
                    this.agent.addScore(25, 'TOPOLOGY');
                    this.agent.onBoundaryWrap(this.player.q, this.player.r);
                } else if (newR > 10) {
                    newR = -10;
                    this.player.parityFlipped = !this.player.parityFlipped;
                    this.log('Möbius wrap: bottom→top', '#00ffff');
                    this.agent.addScore(25, 'TOPOLOGY');
                    this.agent.onBoundaryWrap(this.player.q, this.player.r);
                }
                
                // SEAM CROSSING at r=0
                if (this.hexGrid.crossesSeam(this.player.r, newR)) {
                    this.player.parityFlipped = !this.player.parityFlipped;
                    this.seamCrossings++;
                    this.log('Seam crossed!', '#00ffff');
                    this.agent.addScore(10, 'TOPOLOGY');
                }
                
                this.player.q = newQ;
                this.player.r = newR;
                this.player.turn++;
                this.player.age++;
                
                // Track movement
                this.agent.onMovement(1);
                
                // Survival bonus every 10 turns
                if (this.player.age % 10 === 0) {
                    this.agent.onSurvival(this.player.age, this.player.stage);
                }
                
                // Check for plateau discovery
                this.checkPlateaus();
                
                this.checkLifecycleAdvancement();
                this.checkPredators();
                this.updatePlayerSprite();
                this.updateAllUI();
                this.drawWorld();
            }
            
            checkPlateaus() {
                // Calculate current stability
                let stability = 0;
                ['Notch', 'Egfr', 'hh', 'wg'].forEach(gene => {
                    if (this.player.genome.slots[gene]) {
                        stability += LOCI[gene].effects.viability || 0;
                    }
                });
                stability = stability + 50 - this.player.genome.instability * 5;
                
                const plateau = this.museum.checkAndSave(
                    this.player.genome, 
                    stability, 
                    this.generation
                );
                
                if (plateau) {
                    this.log(`★ PLATEAU: ${plateau.name}!`, '#00ff00');
                    this.agent.addScore(500, 'PLATEAU DISCOVERED');
                    this.showAchievementNotification(`🏆 Plateau Discovered: ${plateau.name}`);
                }
            }
            
            passTurn() {
                this.player.turn++;
                this.player.age++;
                this.checkLifecycleAdvancement();
                this.updateAllUI();
            }
            
            checkLifecycleAdvancement() {
                if (this.player.age >= this.player.maxAge) {
                    const stages = ['LARVA', 'PUPA', 'ADULT'];
                    const idx = stages.indexOf(this.player.stage);
                    if (idx < stages.length - 1) {
                        this.player.stage = stages[idx + 1];
                        this.player.age = 0;
                        this.player.maxAge = this.player.stage === 'ADULT' ? 300 : 30; // Adults live 60 seconds!
                        this.log(`⟹ ${this.player.stage}`, '#00ffff');
                        this.updatePlayerSprite();
                    } else {
                        this.die('old age');
                    }
                }
            }
            
            feed() {
                const food = this.foodSources.find(f => f.q === this.player.q && f.r === this.player.r && f.respawnTimer === 0);
                if (!food) return;
                
                if (food.type === 'ENERGY') {
                    // Energy food - simple, no risk
                    this.player.energy = Math.min(100, this.player.energy + 30);
                    this.log('✓ Energy +30', '#00ff00');
                    this.createParticleEffect(this.player.q, this.player.r, 0x00ff00, 10);
                    this.showScorePopup(this.player.q, this.player.r, '+50', 0xffff00);
                    this.agent.onFeeding('ENERGY');
                } else {
                    // DNA food - USE EoP SYSTEM for risk/reward!
                    if (!this.player.genome.slots[food.gene]) {
                        const cf = this.eopSystem.calculateCF(this.player, food, this.player.posture);
                        const result = this.eopSystem.roll(this.player, food.gene, cf, this.player.posture);
                        
                        if (result.outcome === 'SI') {
                            // SUCCESS!
                            this.player.genome.slots[food.gene] = true;
                            this.player.genome.instability = Math.max(0, this.player.genome.instability + result.instability);
                            this.log(`✓ DNA: ${food.gene} [SI]`, '#00ff00');
                            this.createParticleEffect(this.player.q, this.player.r, food.color, 15);
                            this.showScorePopup(this.player.q, this.player.r, `+${result.score}`, 0x00ffff);
                            this.agent.onFeeding('DNA');
                        } else if (result.outcome === 'CS') {
                            // CRITICAL FAILURE!
                            this.player.genome.instability += result.instability;
                            this.player.stunned = result.stun;
                            this.log(`☠ CS! Stunned ${result.stun} turns`, '#ff0000');
                            this.createParticleEffect(this.player.q, this.player.r, 0xff0000, 20);
                            this.showScorePopup(this.player.q, this.player.r, `${result.score}`, 0xff0000);
                            this.agent.addScore(result.score, 'CRITICAL FAILURE');
                        } else {
                            // MIXED/NEUTRAL
                            this.player.genome.slots[food.gene] = true;
                            this.player.genome.instability += result.instability;
                            this.log(`~ DNA: ${food.gene} [MF]`, '#ffff00');
                            this.createParticleEffect(this.player.q, this.player.r, food.color, 10);
                            this.showScorePopup(this.player.q, this.player.r, `+${result.score}`, 0xffff00);
                            this.agent.addScore(result.score, 'DNA MIXED');
                        }
                    }
                    this.player.energy = Math.min(100, this.player.energy + 10);
                }
                
                food.respawnTimer = 10;
                this.drawWorld();
                this.updateAllUI();
            }
            
            showScorePopup(q, r, text, color) {
                const pos = this.hexGrid.hexToPixel(q, r);
                const popup = this.add.text(pos.x, pos.y - 20, text, {
                    fontSize: '20px',
                    fontFamily: 'Courier New',
                    fontStyle: 'bold',
                    color: '#' + color.toString(16).padStart(6, '0')
                });
                popup.setOrigin(0.5);
                
                this.tweens.add({
                    targets: popup,
                    y: pos.y - 60,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => popup.destroy()
                });
            }
            
            mate() {
                if (this.player.stage !== 'ADULT' || this.brood) return;
                const near = this.npcFlies.find(n => Math.abs(n.q - this.player.q) + Math.abs(n.r - this.player.r) <= 2);
                if (!near) return;
                
                this.brood = [];
                for (let i = 0; i < 8; i++) {
                    this.brood.push({
                        id: i + 1,
                        genome: JSON.parse(JSON.stringify(this.player.genome))
                    });
                }
                
                // PARTICLE EFFECT!
                this.createParticleEffect(this.player.q, this.player.r, 0xff69b4, 20);
                this.showScorePopup(this.player.q, this.player.r, '+500', 0xff69b4);
                
                this.log('═══ BROOD LAID ═══', '#ff69b4');
                this.agent.onMating();
                document.getElementById('has-brood').style.display = 'block';
            }
            
            showAchievementNotification(msg) {
                const notification = this.add.text(450, 100, msg, {
                    fontSize: '24px',
                    fontFamily: 'Courier New',
                    fontStyle: 'bold',
                    color: '#ffff00',
                    backgroundColor: '#000000',
                    padding: { x: 20, y: 10 }
                });
                notification.setOrigin(0.5);
                notification.setScrollFactor(0);
                notification.setDepth(1000);
                
                this.tweens.add({
                    targets: notification,
                    y: 80,
                    duration: 200,
                    ease: 'Back.easeOut'
                });
                
                this.time.delayedCall(3000, () => {
                    this.tweens.add({
                        targets: notification,
                        alpha: 0,
                        y: 60,
                        duration: 500,
                        onComplete: () => notification.destroy()
                    });
                });
            }
            
            createParticleEffect(q, r, color, count) {
                const pos = this.hexGrid.hexToPixel(q, r);
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 100;
                    const particle = this.add.circle(pos.x, pos.y, 3, color);
                    particle.setAlpha(0.8);
                    
                    this.tweens.add({
                        targets: particle,
                        x: pos.x + Math.cos(angle) * speed,
                        y: pos.y + Math.sin(angle) * speed,
                        alpha: 0,
                        duration: 500 + Math.random() * 500,
                        onComplete: () => particle.destroy()
                    });
                }
            }
            
            selectOffspring(index) {
                if (!this.brood || index >= this.brood.length) return;
                
                this.generation++;
                this.agent.onGeneration(this.generation);
                
                this.player.genome = JSON.parse(JSON.stringify(this.brood[index].genome));
                this.player.stage = 'LARVA';
                this.player.age = 0;
                this.player.maxAge = 30;
                this.player.energy = 100;
                this.player.q = 0;
                this.player.r = 0;
                this.player.alive = true;
                
                this.brood = null;
                document.getElementById('has-brood').style.display = 'none';
                
                this.updatePlayerSprite();
                this.log(`═══ GEN ${this.generation} ═══`, '#00ff00');
                this.updateAllUI();
            }
            
            checkPredators() {
                this.predators.forEach(pred => {
                    const dist = Math.abs(pred.q - this.player.q) + Math.abs(pred.r - this.player.r);
                    if (dist <= 1) this.die('predation');
                });
            }
            
            updatePredators() {
                this.predators.forEach(pred => {
                    if (Math.random() < 0.4) {
                        if (pred.behavior === 'chase' && pred.speed > 0) {
                            // Chase player if within vision
                            const dq = this.player.q - pred.q;
                            const dr = this.player.r - pred.r;
                            const dist = Math.abs(dq) + Math.abs(dr);
                            
                            if (dist <= pred.vision) {
                                if (Math.abs(dq) > Math.abs(dr)) {
                                    pred.q += Math.sign(dq);
                                } else {
                                    pred.r += Math.sign(dr);
                                }
                            }
                        } else if (pred.behavior === 'patrol' && pred.speed > 0) {
                            // Patrol back and forth
                            pred.patrolCount++;
                            if (pred.patrolCount >= 4) {
                                pred.patrolCount = 0;
                                pred.patrolDir *= -1;
                            }
                            
                            if (Math.random() < 0.5) {
                                pred.q += pred.patrolDir * pred.speed;
                            } else {
                                pred.r += pred.patrolDir * pred.speed;
                            }
                        }
                        // web type doesn't move (speed=0)
                    }
                });
                this.drawPredators();
            }
            
            drawPredators() {
                this.predatorGraphics.clear();
                this.predators.forEach(pred => {
                    const pos = this.hexGrid.hexToPixel(pred.q, pred.r);
                    
                    // Vision radius
                    this.predatorGraphics.fillStyle(pred.color, 0.1);
                    this.predatorGraphics.fillCircle(pos.x, pos.y, this.hexSize * pred.vision);
                    
                    this.predatorGraphics.fillStyle(pred.color, 0.9);
                    this.predatorGraphics.lineStyle(3, pred.color, 1);
                    
                    if (pred.type === 'JUMPING_SPIDER') {
                        // X shape
                        this.predatorGraphics.beginPath();
                        this.predatorGraphics.moveTo(pos.x - 8, pos.y - 8);
                        this.predatorGraphics.lineTo(pos.x + 8, pos.y + 8);
                        this.predatorGraphics.moveTo(pos.x + 8, pos.y - 8);
                        this.predatorGraphics.lineTo(pos.x - 8, pos.y + 8);
                        this.predatorGraphics.strokePath();
                    } else if (pred.type === 'DRAGONFLY') {
                        // Diamond shape
                        this.predatorGraphics.beginPath();
                        this.predatorGraphics.moveTo(pos.x, pos.y - 10);
                        this.predatorGraphics.lineTo(pos.x + 7, pos.y);
                        this.predatorGraphics.lineTo(pos.x, pos.y + 10);
                        this.predatorGraphics.lineTo(pos.x - 7, pos.y);
                        this.predatorGraphics.closePath();
                        this.predatorGraphics.fillPath();
                        this.predatorGraphics.strokePath();
                    } else if (pred.type === 'ORB_SPIDER') {
                        // Web pattern
                        this.predatorGraphics.fillCircle(pos.x, pos.y, 6);
                        for (let i = 0; i < 8; i++) {
                            const angle = i * Math.PI / 4;
                            this.predatorGraphics.beginPath();
                            this.predatorGraphics.moveTo(pos.x, pos.y);
                            this.predatorGraphics.lineTo(
                                pos.x + Math.cos(angle) * 15,
                                pos.y + Math.sin(angle) * 15
                            );
                            this.predatorGraphics.strokePath();
                        }
                    }
                });
            }
            
            updateNPCs() {
                this.npcFlies.forEach(npc => {
                    if (Math.random() < 0.5) { // Increased from 0.3 to 0.5
                        const dirs = [{ q: 0, r: -1 }, { q: 0, r: 1 }, { q: -1, r: 0 }, { q: 1, r: 0 }];
                        const dir = dirs[Math.floor(Math.random() * dirs.length)];
                        npc.q += dir.q;
                        npc.r += dir.r;
                    }
                });
                this.drawNPCs();
            }
            
            drawNPCs() {
                this.npcGraphics.clear();
                this.npcFlies.forEach(npc => {
                    const pos = this.hexGrid.hexToPixel(npc.q, npc.r);
                    this.npcGraphics.fillStyle(0xFF69B4, 0.8);
                    this.npcGraphics.fillCircle(pos.x, pos.y, 8);
                });
            }
            
            die(cause) {
                this.player.alive = false;
                this.log(`DEATH: ${cause}`, '#ff0000');
                
                this.time.delayedCall(2000, () => {
                    this.generation++;
                    this.player.stage = 'LARVA';
                    this.player.age = 0;
                    this.player.maxAge = 30;
                    this.player.energy = 100;
                    this.player.q = 0;
                    this.player.r = 0;
                    this.player.alive = true;
                    this.updatePlayerSprite();
                    this.log(`Respawned - Gen ${this.generation}`, '#00ff00');
                    this.updateAllUI();
                });
            }
            
            executeAction(action) {
                if (action.type === 'MOVE') {
                    this.moveInDirection(action.direction);
                } else if (action.type === 'FEED') {
                    this.feed();
                    this.player.turn++;
                    this.player.age++;
                } else if (action.type === 'MATE') {
                    this.mate();
                    this.player.turn++;
                } else if (action.type === 'SELECT_OFFSPRING') {
                    this.selectOffspring(action.index);
                }
                
                this.agent.reward(this);
                this.updateAllUI();
            }
            
            updateAllUI() {
                document.getElementById('stage-display').textContent = this.player.stage;
                document.getElementById('age-display').textContent = this.player.age;
                document.getElementById('max-age-display').textContent = this.player.maxAge;
                document.getElementById('gen-display').textContent = this.generation;
                document.getElementById('energy-display').textContent = Math.floor(this.player.energy);
                
                const loci = Object.keys(this.player.genome.slots).filter(k => this.player.genome.slots[k]).length;
                document.getElementById('loci-count').textContent = loci;
                document.getElementById('instability-display').textContent = this.player.genome.instability;
                
                const dnaItems = this.player.inventory.length;
                document.getElementById('dna-count').textContent = dnaItems;
                
                document.getElementById('npc-count').textContent = this.npcFlies.length;
                
                const nearFood = this.foodSources.filter(f => {
                    const dist = Math.abs(f.q - this.player.q) + Math.abs(f.r - this.player.r);
                    return dist <= 5 && f.respawnTimer === 0;
                }).length;
                document.getElementById('food-count').textContent = nearFood;
                
                document.getElementById('ai-fitness').textContent = Math.floor(this.agent.currentFitness);
                document.getElementById('ai-strategy').textContent = this.agent.currentStrategy;
                
                // SCORING UI
                document.getElementById('score-display').textContent = this.agent.score;
                document.getElementById('high-score-display').textContent = this.agent.highScore;
                document.getElementById('gens-reached').textContent = this.agent.generationsReached;
                document.getElementById('total-mates').textContent = this.agent.totalMates;
                document.getElementById('total-food').textContent = this.agent.totalFood;
                document.getElementById('total-dna').textContent = this.agent.totalDNA;
                document.getElementById('total-dist').textContent = Math.floor(this.agent.totalDistance);
                
                // TOPOLOGY UI
                const parityStatus = document.getElementById('parity-status');
                if (parityStatus) {
                    parityStatus.innerHTML = this.player.parityFlipped ? 
                        'Parity: <span class="warning">FLIPPED</span>' : 
                        'Parity: <span class="quantum">NORMAL</span>';
                }
                const seamCount = document.getElementById('seam-count');
                if (seamCount) {
                    seamCount.innerHTML = `Seams: <span class="stat">${this.seamCrossings}</span>`;
                }
                
                // PLATEAU UI
                const plateauCount = document.getElementById('plateau-count');
                if (plateauCount) {
                    plateauCount.textContent = this.museum.plateaus.length;
                }
                const plateauRecent = document.getElementById('plateau-recent');
                if (plateauRecent) {
                    if (this.museum.plateaus.length === 0) {
                        plateauRecent.textContent = 'None yet';
                    } else {
                        const recent = this.museum.plateaus.slice(-3).reverse();
                        plateauRecent.innerHTML = recent.map(p => 
                            `${p.name} (G${p.generation})`
                        ).join('<br>');
                    }
                }
                
                // Respawn food
                this.foodSources.forEach(f => {
                    if (f.respawnTimer > 0) {
                        f.respawnTimer--;
                        if (f.respawnTimer === 0) this.drawWorld();
                    }
                });
            }
            
            log(message, color = '#ffff00') {
                console.log(message);
            }
        }
        
        // ============================================================================
        // PATCH 5: SELF-TESTS
        // ============================================================================
        
        // TEST: GPU manifold updates state (only meaningful if WebGL2 is present)
        (function testGPUState() {
            const m = new GPUFILManifold(256);
            if (!m.useCPU) {
                const before = m.state.slice(0, 8).map(v => v.toFixed(4)).join(',');
                console.log('TEST: GPU state before evolve:', before);
                m.evolve();
                m.downloadState();
                const after = m.state.slice(0, 8).map(v => v.toFixed(4)).join(',');
                console.log('TEST: GPU state after evolve+download:', after);
                if (before === after) {
                    console.error('TEST ❌ GPU state did not change after evolve+download');
                    console.log('TEST: This suggests shader may not be executing or readback failed');
                    console.log('TEST: Game will fall back to CPU computation in neural forward pass');
                } else {
                    console.log('TEST ✔ GPU evolve+download changes state');
                }
            } else {
                console.log('TEST ◦ GPU fallback (CPU path), skipped evolve test');
            }
        })();
        
        // TEST: Sensory bands don't collide
        (function testBands() {
            const agent = new MassiveFILAgent();
            const {DIR_START, DIR_LEN, CHEM_START, CHEM_LEN, INT_START} = agent.BANDS;
            if (DIR_START + DIR_LEN > CHEM_START) {
                console.error('TEST ❌ DIR overlaps CHEM');
            } else if (CHEM_START + CHEM_LEN > INT_START) {
                console.error('TEST ❌ CHEM overlaps INT');
            } else {
                console.log('TEST ✔ Sensory bands non-overlapping');
            }
        })();
        
        const config = {
            type: Phaser.AUTO,
            width: 900,
            height: 720,
            parent: 'phaser-canvas',
            backgroundColor: '#1a1a1a',
            scene: [GameScene]
        };
        
        const game = new Phaser.Game(config);
    </script>
</body>
</html>
