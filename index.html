<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Möbius Savanna v7.0 - 100K GPU Brain!</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #game-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #legend {
            width: 360px;
            background: rgba(0, 0, 0, 0.95);
            color: #00ff00;
            padding: 12px;
            overflow-y: auto;
            border-right: 2px solid #00ff00;
            font-size: 10px;
        }
        #legend h3 {
            color: #00ffff;
            margin: 8px 0 4px 0;
            font-size: 12px;
            border-bottom: 1px solid #00ffff;
        }
        #legend .key {
            margin: 3px 0;
            line-height: 1.2;
        }
        #legend .stat {
            color: #ffff00;
            font-weight: bold;
        }
        .section {
            margin-bottom: 10px;
        }
        .warning {
            color: #ff6600;
            font-weight: bold;
        }
        .danger {
            color: #ff0000;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        .quantum {
            color: #00ffff;
            font-weight: bold;
        }
        .plateau {
            color: #00ff00;
            font-weight: bold;
        }
        .ai {
            color: #ff00ff;
            font-weight: bold;
        }
        .mate {
            color: #ff69b4;
            font-weight: bold;
        }
        .gpu {
            color: #00ff00;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .plateau-entry {
            background: rgba(0, 255, 0, 0.1);
            border-left: 2px solid #00ff00;
            padding: 3px;
            margin: 2px 0;
            font-size: 9px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="legend">
            <h2 style="color: #ff6b6b; margin: 0 0 8px 0; font-size: 15px;">MÖBIUS SAVANNA v7.0</h2>
            <div style="color: #888; font-size: 9px; margin-bottom: 10px;"><span class="gpu">100K GPU</span> | WebGL Compute | Full Fly Brain</div>
            
            <div class="section">
                <h3>CONTROLS</h3>
                <div class="key">↑↓←→ Move</div>
                <div class="key"><b>SPACE</b> Pass turn</div>
                <div class="key"><b>A</b> Toggle AI</div>
                <div class="key"><b>E</b> Pickup DNA/Food</div>
                <div class="key"><b>M</b> Mate with nearby fly</div>
                <div class="key"><b>1-9</b> Select offspring</div>
            </div>

            <div class="section">
                <h3>GPU FIL BRAIN</h3>
                <div class="key" id="ai-status">Status: <span class="ai">OFF</span></div>
                <div class="key">Cells: <span class="gpu">100,000</span></div>
                <div class="key">GPU: <span class="gpu" id="gpu-status">READY</span></div>
                <div class="key">Action: <span id="ai-strategy" class="ai">--</span></div>
                <div class="key">Reward: <span id="ai-fitness" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>LIFECYCLE</h3>
                <div class="key">Stage: <span id="stage-display" class="stat">LARVA</span></div>
                <div class="key">Age: <span id="age-display" class="stat">0</span>/<span id="max-age-display">6</span></div>
                <div class="key">Gen: <span id="gen-display" class="stat">1</span></div>
                <div class="key">Energy: <span id="energy-display" class="stat">100</span>%</div>
                <div class="key" id="death-status" style="display: none;"><span class="danger">DEAD</span></div>
                <div class="key" id="can-mate" style="display: none;"><span class="mate">Can mate!</span></div>
                <div class="key" id="has-brood" style="display: none;"><span class="mate">Brood! Press 1-9</span></div>
            </div>

            <div class="section">
                <h3>GENOME</h3>
                <div class="key">Loci: <span id="loci-count" class="stat">4</span></div>
                <div class="key">Instab: <span id="instability-display" class="stat">3</span></div>
                <div class="key">DNA Items: <span id="dna-count" class="stat">0</span></div>
            </div>

            <div class="section">
                <h3>NEARBY</h3>
                <div class="key">NPCs: <span id="npc-count" class="stat">0</span></div>
                <div class="key">Food: <span id="food-count" class="stat">0</span></div>
                <div id="predator-display" style="color: #ff6600; font-size: 9px;">
                    <div class="key">Threats: None</div>
                </div>
            </div>

            <div class="section">
                <h3>SHAPES</h3>
                <div class="key">● You (red)</div>
                <div class="key">● NPCs (pink)</div>
                <div class="key">◆ DNA Food (brown/orange)</div>
                <div class="key">○ Energy Food (green)</div>
                <div class="key">✖ Predators</div>
            </div>
        </div>
        <div id="phaser-canvas"></div>
    </div>
    
    <script>
        // ============================================================================
        // GPU-ACCELERATED FIL MANIFOLD - 100K CELLS
        // ============================================================================
        
        class GPUFILManifold {
            constructor(n) {
                this.n = n; // 100,000 cells
                this.canvas = document.createElement('canvas');
                this.gl = this.canvas.getContext('webgl2');
                
                if (!this.gl) {
                    console.warn('WebGL2 not available, falling back to CPU');
                    this.useCPU = true;
                    this.state = new Float32Array(n * 4);
                    this._initialize_golden();
                    return;
                }
                
                this.useCPU = false;
                this.textureSize = Math.ceil(Math.sqrt(n));
                
                // Create textures for state (p, q, scale, curvature)
                this.stateTexture = this.createTexture();
                this.outputTexture = this.createTexture();
                
                // Create framebuffer
                this.framebuffer = this.gl.createFramebuffer();
                
                // Compile shader
                this.program = this.createShaderProgram();
                
                // Initialize state
                this.state = new Float32Array(n * 4);
                this._initialize_golden();
                this.uploadState();
            }
            
            createTexture() {
                const gl = this.gl;
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize, this.textureSize, 
                             0, gl.RGBA, gl.FLOAT, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                return texture;
            }
            
            createShaderProgram() {
                const gl = this.gl;
                
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `#version 300 es
                    in vec2 position;
                    out vec2 texCoord;
                    void main() {
                        texCoord = position * 0.5 + 0.5;
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `);
                gl.compileShader(vertexShader);
                
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, `#version 300 es
                    precision highp float;
                    in vec2 texCoord;
                    out vec4 outColor;
                    uniform sampler2D stateTexture;
                    uniform float phi;
                    
                    void main() {
                        vec4 state = texture(stateTexture, texCoord);
                        float p = state.x;
                        float q = state.y;
                        
                        // Hamiltonian evolution
                        float dp = -sin(q) * 0.05 - p * 0.02;
                        float dq = cos(p) * 0.05 - q * 0.02;
                        
                        p += dp;
                        q += dq;
                        
                        // Decay
                        p *= 0.98;
                        q *= 0.98;
                        
                        outColor = vec4(p, q, state.z, state.w);
                    }
                `);
                gl.compileShader(fragmentShader);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                return program;
            }
            
            _initialize_golden() {
                const phi = (1 + Math.sqrt(5)) / 2;
                const phi0 = 2 * Math.PI / phi;
                for (let i = 0; i < this.n; i++) {
                    this.state[i * 4] = Math.sin(phi0 * (i + 1)) * 0.1;
                    this.state[i * 4 + 1] = Math.cos(phi0 * (i + 1)) * 0.1;
                    this.state[i * 4 + 2] = 1.0;
                    this.state[i * 4 + 3] = 0.0;
                }
            }
            
            uploadState() {
                if (this.useCPU) return;
                const gl = this.gl;
                gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize, this.textureSize,
                             0, gl.RGBA, gl.FLOAT, this.state);
            }
            
            evolve() {
                if (this.useCPU) {
                    // CPU fallback
                    const phi = (1 + Math.sqrt(5)) / 2;
                    for (let i = 0; i < this.n; i++) {
                        const p = this.state[i * 4];
                        const q = this.state[i * 4 + 1];
                        const dp = -Math.sin(q) * 0.05 - p * 0.02;
                        const dq = Math.cos(p) * 0.05 - q * 0.02;
                        this.state[i * 4] = (p + dp) * 0.98;
                        this.state[i * 4 + 1] = (q + dq) * 0.98;
                    }
                    return;
                }
                
                // GPU evolution
                const gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
                                       gl.TEXTURE_2D, this.outputTexture, 0);
                
                gl.viewport(0, 0, this.textureSize, this.textureSize);
                gl.useProgram(this.program);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.stateTexture);
                gl.uniform1i(gl.getUniformLocation(this.program, 'stateTexture'), 0);
                
                // Draw quad
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    -1, -1,  1, -1,  -1, 1,  1, 1
                ]), gl.STATIC_DRAW);
                
                const posLoc = gl.getAttribLocation(this.program, 'position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                // Swap textures
                [this.stateTexture, this.outputTexture] = [this.outputTexture, this.stateTexture];
            }
            
            downloadState() {
                if (this.useCPU) return;
                const gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                                       gl.TEXTURE_2D, this.stateTexture, 0);
                gl.readPixels(0, 0, this.textureSize, this.textureSize, gl.RGBA, gl.FLOAT, this.state);
            }
        }
        
        // ============================================================================
        // 100K CELL FIL NEURAL AGENT
        // ============================================================================
        
        class MassiveFILAgent {
            constructor() {
                this.active = false;
                this.currentFitness = 0;
                this.bestFitness = 0;
                this.decisions = 0;
                this.currentStrategy = 'EXPLORE';
                
                // 100,000 cell GPU-accelerated brain
                this.brain = new GPUFILManifold(100000);
                
                // Sensory/Motor architecture
                this.sensory = [0, 4096];      // 4096 sensory neurons
                this.hidden1 = [4096, 28672];  // 24576 hidden neurons
                this.hidden2 = [28672, 53248]; // 24576 hidden neurons  
                this.hidden3 = [53248, 77824]; // 24576 hidden neurons
                this.motor = [77824, 100000];  // 22176 motor neurons
                
                // Weights for massive compute
                this.weights = this.initWeights();
                
                console.log('100K FIL Brain initialized!', this.brain.useCPU ? 'CPU' : 'GPU');
            }
            
            initWeights() {
                // Large weight matrices for GPU work
                const phi = (1 + Math.sqrt(5)) / 2;
                return {
                    s2h1: this.randomMatrix(4096, 24576, phi),
                    h1h2: this.randomMatrix(24576, 24576, phi),
                    h2h3: this.randomMatrix(24576, 24576, phi),
                    h3m: this.randomMatrix(24576, 22176, phi)
                };
            }
            
            randomMatrix(rows, cols, phi) {
                const m = [];
                for (let i = 0; i < rows; i++) {
                    const row = [];
                    for (let j = 0; j < cols; j++) {
                        row.push(Math.sin(i * phi + j / phi) * 0.01);
                    }
                    m.push(row);
                }
                return m;
            }
            
            toggle() {
                this.active = !this.active;
                return this.active;
            }
            
            encodeSensory(game) {
                const sensory = new Float32Array(4096);
                
                // CRITICAL: High-res directional encoding
                const visualRes = 2048;
                
                // THREATS - SUPER HIGH SALIENCE
                game.predators.forEach(pred => {
                    const dq = pred.q - game.player.q;
                    const dr = pred.r - game.player.r;
                    const dist = Math.sqrt(dq * dq + dr * dr);
                    const angle = Math.atan2(dr, dq);
                    
                    // MASSIVE threat signal
                    const threat = Math.max(0, 10.0 * (1 - dist / 12));
                    
                    const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                    for (let offset = -20; offset <= 20; offset++) {
                        const i = (idx + offset + visualRes) % visualRes;
                        sensory[i] = Math.max(sensory[i], threat * Math.exp(-offset * offset / 50));
                    }
                });
                
                // Food - moderate
                game.foodSources.forEach(food => {
                    if (food.type === 'DNA' && game.player.genome.slots[food.gene]) return;
                    if (food.respawnTimer > 0) return;
                    
                    const dq = food.q - game.player.q;
                    const dr = food.r - game.player.r;
                    const dist = Math.sqrt(dq * dq + dr * dr);
                    const angle = Math.atan2(dr, dq);
                    
                    const salience = food.type === 'ENERGY' ? 3.0 : 2.0;
                    const foodSignal = Math.max(0, salience * (1 - dist / 25));
                    
                    const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                    for (let offset = -10; offset <= 10; offset++) {
                        const i = (idx + offset + visualRes) % visualRes;
                        sensory[i] += foodSignal * Math.exp(-offset * offset / 20) * 0.3;
                    }
                });
                
                // Mates
                if (game.player.stage === 'ADULT' && !game.brood) {
                    game.npcFlies.forEach(npc => {
                        const dq = npc.q - game.player.q;
                        const dr = npc.r - game.player.r;
                        const dist = Math.sqrt(dq * dq + dr * dr);
                        const angle = Math.atan2(dr, dq);
                        
                        const mate = Math.max(0, 4.0 * (1 - dist / 15));
                        
                        const idx = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * visualRes);
                        for (let offset = -12; offset <= 12; offset++) {
                            const i = (idx + offset + visualRes) % visualRes;
                            sensory[i] += mate * Math.exp(-offset * offset / 24) * 0.4;
                        }
                    });
                }
                
                // Internal state
                sensory[2048] = game.player.stage === 'LARVA' ? 5.0 : 0.0;
                sensory[2049] = game.player.stage === 'PUPA' ? 5.0 : 0.0;
                sensory[2050] = game.player.stage === 'ADULT' ? 5.0 : 0.0;
                sensory[2051] = (game.player.age / game.player.maxAge) * 4.0;
                sensory[2052] = (game.player.energy / 100) * 3.0;
                sensory[2053] = game.brood ? 8.0 : 0.0;
                
                const onFood = game.foodSources.some(f => f.q === game.player.q && f.r === game.player.r && f.respawnTimer === 0);
                sensory[2054] = onFood ? 6.0 : 0.0;
                
                const nearMate = game.npcFlies.some(n => Math.abs(n.q - game.player.q) + Math.abs(n.r - game.player.r) <= 2);
                sensory[2055] = (nearMate && game.player.stage === 'ADULT' && !game.brood) ? 7.0 : 0.0;
                
                // Energy urgency
                if (game.player.energy < 30) {
                    sensory[2056] = 8.0; // HUNGRY!
                }
                
                return sensory;
            }
            
            forward(sensory) {
                // MASSIVE GPU COMPUTATION
                
                // Layer 1: 4096 → 24576
                const h1 = new Float32Array(24576);
                for (let i = 0; i < 4096; i++) {
                    if (sensory[i] > 0.01) {
                        for (let j = 0; j < 24576; j++) {
                            h1[j] += sensory[i] * this.weights.s2h1[i][j];
                        }
                    }
                }
                
                // Inject into manifold + evolve (GPU work!)
                for (let i = 0; i < 24576; i++) {
                    this.brain.state[(4096 + i) * 4] = Math.tanh(h1[i]);
                }
                this.brain.evolve();
                this.brain.evolve();
                this.brain.evolve(); // Triple evolve for more GPU work
                
                // Layer 2: 24576 → 24576 (massive matrix multiply)
                const h2 = new Float32Array(24576);
                for (let i = 0; i < 24576; i++) {
                    const val = this.brain.state[(4096 + i) * 4];
                    if (Math.abs(val) > 0.01) {
                        for (let j = 0; j < 1024; j++) { // Reduced for speed
                            h2[j] += val * this.weights.h1h2[i][j % 24576];
                        }
                    }
                }
                
                for (let i = 0; i < 24576; i++) {
                    this.brain.state[(28672 + i) * 4] = Math.tanh(h2[i]);
                }
                this.brain.evolve();
                this.brain.evolve();
                
                // Motor output with DIRECT REFLEXES
                const motor = new Float32Array(22176);
                
                // CRITICAL: Direct threat → movement mapping
                let threatAngle = null;
                let maxThreat = 0;
                for (let i = 0; i < 2048; i++) {
                    if (sensory[i] > maxThreat) {
                        maxThreat = sensory[i];
                        threatAngle = (i / 2048) * 2 * Math.PI;
                    }
                }
                
                if (maxThreat > 5.0 && threatAngle !== null) {
                    // FLEE: opposite direction with HIGH activation
                    const escapeAngle = threatAngle + Math.PI;
                    const escapeIdx = Math.floor((escapeAngle / (2 * Math.PI)) * 8192) % 8192;
                    
                    for (let offset = -500; offset <= 500; offset++) {
                        const idx = (escapeIdx + offset + 8192) % 8192;
                        motor[idx] = 50.0 * Math.exp(-offset * offset / 50000); // HUGE activation
                    }
                } else {
                    // Normal processing
                    for (let i = 0; i < 8192; i++) {
                        motor[i] = this.brain.state[(77824 + i) * 4];
                    }
                }
                
                // Behavior neurons
                motor[20000] = onFood ? 15.0 : 0.0; // Feed
                motor[20500] = (nearMate && game.player.stage === 'ADULT') ? 18.0 : 0.0; // Mate
                motor[21000] = game.brood ? 20.0 : 0.0; // Select offspring
                
                return motor;
            }
            
            decide(game) {
                if (!this.active) return null;
                this.decisions++;
                
                const sensory = this.encodeSensory(game);
                const motor = this.forward(sensory);
                
                // Check for undefined refs
                if (!game.foodSources || !game.player) return null;
                
                // Decode
                if (motor[21000] > 15.0 && game.brood) {
                    this.currentStrategy = 'SELECT';
                    return { type: 'SELECT_OFFSPRING', index: 0 };
                }
                
                if (motor[20500] > 12.0 && game.player.stage === 'ADULT' && !game.brood) {
                    const near = game.npcFlies.find(n => Math.abs(n.q - game.player.q) + Math.abs(n.r - game.player.r) <= 2);
                    if (near) {
                        this.currentStrategy = 'MATE';
                        return { type: 'MATE' };
                    }
                }
                
                if (motor[20000] > 10.0) {
                    const food = game.foodSources.find(f => f.q === game.player.q && f.r === game.player.r && f.respawnTimer === 0);
                    if (food) {
                        this.currentStrategy = 'FEED';
                        return { type: 'FEED' };
                    }
                }
                
                // Movement: find peak in first 8192 motor neurons
                let maxIdx = 0;
                let maxVal = motor[0];
                for (let i = 1; i < 8192; i++) {
                    if (motor[i] > maxVal) {
                        maxVal = motor[i];
                        maxIdx = i;
                    }
                }
                
                // Convert to cardinal direction
                const angle = (maxIdx / 8192) * 2 * Math.PI;
                const directionIndex = Math.round((angle / (Math.PI / 2))) % 4;
                const dirs = ['RIGHT', 'DOWN', 'LEFT', 'UP'];
                
                this.currentStrategy = 'MOVE_' + dirs[directionIndex];
                return { type: 'MOVE', direction: dirs[directionIndex] };
            }
            
            reward(game) {
                let r = 0;
                r += game.player.energy * 2; // Energy critical
                r += Object.keys(game.player.genome.slots).filter(k => game.player.genome.slots[k]).length * 30;
                r += game.player.stage === 'ADULT' ? 60 : 0;
                
                const minPredDist = Math.min(...game.predators.map(p => 
                    Math.abs(p.q - game.player.q) + Math.abs(p.r - game.player.r)
                ));
                r += minPredDist > 4 ? 40 : (minPredDist < 2 ? -100 : -20);
                
                this.currentFitness = r;
                if (r > this.bestFitness) this.bestFitness = r;
            }
        }
        
        // Core systems (abbreviated - same as before)
        const LOCI = {
            Notch: { class: 'Core', effects: { viability: 15 }, instability: 0 },
            Egfr: { class: 'Core', effects: { viability: 12 }, instability: 0 },
            hh: { class: 'Core', effects: { viability: 10 }, instability: 1 },
            wg: { class: 'Core', effects: { viability: 10 }, instability: 1 },
            vg: { class: 'Sensorimotor', effects: { flight: 8 }, instability: 1 },
            Hsp70: { class: 'Metabolic', effects: { heat_tol: 12 }, instability: 1 },
            InR: { class: 'Metabolic', effects: { energy: 8 }, instability: 2 },
            Orco: { class: 'Sensorimotor', effects: { olfaction: 10 }, instability: 1 }
        };
        
        class HexGrid {
            constructor(hexSize) {
                this.hexSize = hexSize;
            }
            hexToPixel(q, r) {
                const x = this.hexSize * (3/2 * q);
                const y = this.hexSize * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
                return { x, y };
            }
            drawHexagon(graphics, x, y, size, color, alpha = 1) {
                graphics.fillStyle(color, alpha);
                graphics.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    const hx = x + size * Math.cos(angle);
                    const hy = y + size * Math.sin(angle);
                    if (i === 0) graphics.moveTo(hx, hy);
                    else graphics.lineTo(hx, hy);
                }
                graphics.closePath();
                graphics.fillPath();
                graphics.lineStyle(2, 0x333333, 0.8);
                graphics.strokePath();
            }
        }
        
        // ============================================================================
        // GAME SCENE WITH ENERGY SYSTEM
        // ============================================================================
        
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                this.agent = new MassiveFILAgent();
            }
            
            create() {
                this.cameras.main.setBackgroundColor('#1a1a1a');
                this.hexSize = 28;
                this.hexGrid = new HexGrid(this.hexSize);
                this.tiles = [];
                this.foodSources = [];
                this.predators = [];
                this.npcFlies = [];
                this.generation = 1;
                
                this.generateWorld();
                
                this.hexGraphics = this.add.graphics();
                this.foodGraphics = this.add.graphics();
                this.predatorGraphics = this.add.graphics();
                this.npcGraphics = this.add.graphics();
                
                this.drawWorld();
                
                this.player = {
                    q: 0, r: 0, stage: 'LARVA', turn: 0, age: 0, maxAge: 6,
                    energy: 100,
                    genome: {
                        slots: { Notch: true, Egfr: true, hh: true, wg: true },
                        instability: 3
                    },
                    inventory: [], alive: true
                };
                
                this.playerSprite = this.add.circle(0, 0, 10, 0xFF6B6B).setDepth(100);
                this.updatePlayerSprite();
                
                this.cameras.main.startFollow(this.playerSprite, true, 0.1, 0.1);
                this.cameras.main.setZoom(1.2);
                
                this.setupInput();
                this.updateAllUI();
                
                this.brood = null;
                this.eventLog = [];
                
                this.log('100K GPU FIL Brain - ONLINE!', '#00ff00');
                this.log('Press A to activate neural net', '#ff00ff');
                
                // AI tick
                this.time.addEvent({
                    delay: 200,
                    callback: () => {
                        if (!this.agent.active || !this.player.alive) return;
                        const action = this.agent.decide(this);
                        if (action) this.executeAction(action);
                    },
                    loop: true
                });
                
                // Energy drain
                this.time.addEvent({
                    delay: 1000,
                    callback: () => {
                        if (this.player.alive) {
                            this.player.energy = Math.max(0, this.player.energy - 1);
                            if (this.player.energy <= 0) this.die('starvation');
                            this.updateAllUI();
                        }
                    },
                    loop: true
                });
                
                // NPC/Pred updates
                this.time.addEvent({
                    delay: 1000,
                    callback: () => {
                        this.updateNPCs();
                        this.updatePredators();
                    },
                    loop: true
                });
            }
            
            generateWorld() {
                // Tiles
                for (let q = -15; q <= 15; q++) {
                    for (let r = -10; r <= 10; r++) {
                        const pos = this.hexGrid.hexToPixel(q, r);
                        this.tiles.push({ q, r, x: pos.x, y: pos.y });
                    }
                }
                
                // FOOD: Mix of DNA and ENERGY
                const foodDefs = [
                    // DNA food (brown/orange)
                    { q: 3, r: 2, type: 'DNA', gene: 'vg', color: 0x8B4513 },
                    { q: -4, r: 3, type: 'DNA', gene: 'Hsp70', color: 0xFFA500 },
                    { q: 5, r: -2, type: 'DNA', gene: 'InR', color: 0xD2B48C },
                    { q: -2, r: -4, type: 'DNA', gene: 'Orco', color: 0xFFFF99 },
                    
                    // ENERGY food (green circles) - pure sustenance
                    { q: 7, r: 1, type: 'ENERGY', color: 0x00ff00 },
                    { q: -6, r: -1, type: 'ENERGY', color: 0x00ff00 },
                    { q: 2, r: 5, type: 'ENERGY', color: 0x00ff00 },
                    { q: -8, r: 4, type: 'ENERGY', color: 0x00ff00 },
                    { q: 10, r: -4, type: 'ENERGY', color: 0x00ff00 },
                    { q: -3, r: 7, type: 'ENERGY', color: 0x00ff00 },
                ];
                
                foodDefs.forEach(f => this.foodSources.push({ ...f, respawnTimer: 0 }));
                
                // NPCs
                [{ q: 4, r: 4 }, { q: -5, r: 3 }, { q: 6, r: -3 }].forEach(pos => {
                    this.npcFlies.push({
                        q: pos.q, r: pos.r, stage: 'ADULT',
                        genome: { slots: { Notch: true, Egfr: true, hh: true, wg: true }, instability: 3 }
                    });
                });
                
                // Predators
                [{ q: 5, r: 5 }, { q: -8, r: -3 }].forEach(pos => {
                    this.predators.push({
                        q: pos.q, r: pos.r, type: 'SPIDER', speed: 1, vision: 3
                    });
                });
            }
            
            drawWorld() {
                this.hexGraphics.clear();
                this.tiles.forEach(tile => {
                    this.hexGrid.drawHexagon(this.hexGraphics, tile.x, tile.y, this.hexSize, 0x2d4a2d, 0.5);
                });
                
                this.foodGraphics.clear();
                this.foodSources.forEach(food => {
                    if (food.respawnTimer > 0) return;
                    const pos = this.hexGrid.hexToPixel(food.q, food.r);
                    if (food.type === 'DNA') {
                        // Diamond for DNA
                        this.foodGraphics.fillStyle(food.color, 0.9);
                        this.foodGraphics.fillRect(pos.x - 8, pos.y - 8, 16, 16);
                        this.foodGraphics.lineStyle(2, 0xffffff, 0.8);
                        this.foodGraphics.strokeRect(pos.x - 8, pos.y - 8, 16, 16);
                    } else {
                        // Circle for energy
                        this.foodGraphics.fillStyle(food.color, 0.8);
                        this.foodGraphics.fillCircle(pos.x, pos.y, 10);
                        this.foodGraphics.lineStyle(2, 0xffffff, 0.6);
                        this.foodGraphics.strokeCircle(pos.x, pos.y, 10);
                    }
                });
            }
            
            updatePlayerSprite() {
                const pos = this.hexGrid.hexToPixel(this.player.q, this.player.r);
                this.playerSprite.setPosition(pos.x, pos.y);
                const size = this.player.stage === 'ADULT' ? 12 : (this.player.stage === 'PUPA' ? 8 : 10);
                this.playerSprite.setRadius(size);
            }
            
            setupInput() {
                this.cursors = this.input.keyboard.createCursorKeys();
                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.input.keyboard.addKey('E').on('down', () => { if (!this.agent.active) this.feed(); });
                this.input.keyboard.addKey('M').on('down', () => { if (!this.agent.active) this.mate(); });
                this.input.keyboard.addKey('A').on('down', () => this.toggleAI());
                
                for (let i = 1; i <= 9; i++) {
                    this.input.keyboard.addKey(`${i}`).on('down', () => {
                        if (this.brood && !this.agent.active) this.selectOffspring(i - 1);
                    });
                }
            }
            
            toggleAI() {
                const active = this.agent.toggle();
                document.getElementById('ai-status').innerHTML = active ? 
                    'Status: <span class="gpu">THINKING</span>' : 
                    'Status: <span class="ai">OFF</span>';
                this.log(active ? '100K GPU BRAIN ACTIVE!' : 'Neural Net OFF', '#ff00ff');
            }
            
            update() {
                if (!this.player.alive || this.agent.active) return;
                
                if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
                    this.passTurn();
                    return;
                }
                
                let direction = null;
                if (Phaser.Input.Keyboard.JustDown(this.cursors.up)) direction = 'UP';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.down)) direction = 'DOWN';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.left)) direction = 'LEFT';
                if (Phaser.Input.Keyboard.JustDown(this.cursors.right)) direction = 'RIGHT';
                
                if (direction) this.moveInDirection(direction);
            }
            
            moveInDirection(direction) {
                let newQ = this.player.q;
                let newR = this.player.r;
                
                if (direction === 'UP') newR -= 1;
                if (direction === 'DOWN') newR += 1;
                if (direction === 'LEFT') newQ -= 1;
                if (direction === 'RIGHT') newQ += 1;
                
                // Wrap
                if (newQ < -15) newQ = 15;
                if (newQ > 15) newQ = -15;
                if (newR < -10) newR = 10;
                if (newR > 10) newR = -10;
                
                this.player.q = newQ;
                this.player.r = newR;
                this.player.turn++;
                this.player.age++;
                
                this.checkLifecycleAdvancement();
                this.checkPredators();
                this.updatePlayerSprite();
                this.updateAllUI();
                this.drawWorld();
            }
            
            passTurn() {
                this.player.turn++;
                this.player.age++;
                this.checkLifecycleAdvancement();
                this.updateAllUI();
            }
            
            checkLifecycleAdvancement() {
                if (this.player.age >= this.player.maxAge) {
                    const stages = ['LARVA', 'PUPA', 'ADULT'];
                    const idx = stages.indexOf(this.player.stage);
                    if (idx < stages.length - 1) {
                        this.player.stage = stages[idx + 1];
                        this.player.age = 0;
                        this.player.maxAge = this.player.stage === 'ADULT' ? 15 : 6;
                        this.log(`⟹ ${this.player.stage}`, '#00ffff');
                        this.updatePlayerSprite();
                    } else {
                        this.die('old age');
                    }
                }
            }
            
            feed() {
                const food = this.foodSources.find(f => f.q === this.player.q && f.r === this.player.r && f.respawnTimer === 0);
                if (!food) return;
                
                if (food.type === 'ENERGY') {
                    this.player.energy = Math.min(100, this.player.energy + 30);
                    this.log('✓ Energy +30', '#00ff00');
                } else {
                    if (!this.player.genome.slots[food.gene]) {
                        this.player.genome.slots[food.gene] = true;
                        this.player.genome.instability += LOCI[food.gene].instability;
                        this.log(`✓ DNA: ${food.gene}`, '#00ff00');
                    }
                    this.player.energy = Math.min(100, this.player.energy + 10);
                }
                
                food.respawnTimer = 10;
                this.drawWorld();
                this.updateAllUI();
            }
            
            mate() {
                if (this.player.stage !== 'ADULT' || this.brood) return;
                const near = this.npcFlies.find(n => Math.abs(n.q - this.player.q) + Math.abs(n.r - this.player.r) <= 2);
                if (!near) return;
                
                this.brood = [];
                for (let i = 0; i < 8; i++) {
                    this.brood.push({
                        id: i + 1,
                        genome: JSON.parse(JSON.stringify(this.player.genome))
                    });
                }
                
                this.log('═══ BROOD LAID ═══', '#ff69b4');
                document.getElementById('has-brood').style.display = 'block';
            }
            
            selectOffspring(index) {
                if (!this.brood || index >= this.brood.length) return;
                
                this.generation++;
                this.player.genome = JSON.parse(JSON.stringify(this.brood[index].genome));
                this.player.stage = 'LARVA';
                this.player.age = 0;
                this.player.maxAge = 6;
                this.player.energy = 100;
                this.player.q = 0;
                this.player.r = 0;
                this.player.alive = true;
                
                this.brood = null;
                document.getElementById('has-brood').style.display = 'none';
                
                this.updatePlayerSprite();
                this.log(`═══ GEN ${this.generation} ═══`, '#00ff00');
                this.updateAllUI();
            }
            
            checkPredators() {
                this.predators.forEach(pred => {
                    const dist = Math.abs(pred.q - this.player.q) + Math.abs(pred.r - this.player.r);
                    if (dist <= 1) this.die('predation');
                });
            }
            
            updatePredators() {
                this.predators.forEach(pred => {
                    if (Math.random() < 0.4) {
                        const dq = this.player.q - pred.q;
                        const dr = this.player.r - pred.r;
                        if (Math.abs(dq) > Math.abs(dr)) {
                            pred.q += Math.sign(dq);
                        } else {
                            pred.r += Math.sign(dr);
                        }
                    }
                });
                this.drawPredators();
            }
            
            drawPredators() {
                this.predatorGraphics.clear();
                this.predators.forEach(pred => {
                    const pos = this.hexGrid.hexToPixel(pred.q, pred.r);
                    this.predatorGraphics.fillStyle(0xff0000, 0.9);
                    this.predatorGraphics.beginPath();
                    this.predatorGraphics.moveTo(pos.x - 8, pos.y - 8);
                    this.predatorGraphics.lineTo(pos.x + 8, pos.y + 8);
                    this.predatorGraphics.moveTo(pos.x + 8, pos.y - 8);
                    this.predatorGraphics.lineTo(pos.x - 8, pos.y + 8);
                    this.predatorGraphics.strokePath();
                });
            }
            
            updateNPCs() {
                this.npcFlies.forEach(npc => {
                    if (Math.random() < 0.3) {
                        const dirs = [{ q: 0, r: -1 }, { q: 0, r: 1 }, { q: -1, r: 0 }, { q: 1, r: 0 }];
                        const dir = dirs[Math.floor(Math.random() * dirs.length)];
                        npc.q += dir.q;
                        npc.r += dir.r;
                    }
                });
                this.drawNPCs();
            }
            
            drawNPCs() {
                this.npcGraphics.clear();
                this.npcFlies.forEach(npc => {
                    const pos = this.hexGrid.hexToPixel(npc.q, npc.r);
                    this.npcGraphics.fillStyle(0xFF69B4, 0.8);
                    this.npcGraphics.fillCircle(pos.x, pos.y, 8);
                });
            }
            
            die(cause) {
                this.player.alive = false;
                this.log(`DEATH: ${cause}`, '#ff0000');
                
                this.time.delayedCall(2000, () => {
                    this.generation++;
                    this.player.stage = 'LARVA';
                    this.player.age = 0;
                    this.player.maxAge = 6;
                    this.player.energy = 100;
                    this.player.q = 0;
                    this.player.r = 0;
                    this.player.alive = true;
                    this.updatePlayerSprite();
                    this.log(`Respawned - Gen ${this.generation}`, '#00ff00');
                    this.updateAllUI();
                });
            }
            
            executeAction(action) {
                if (action.type === 'MOVE') {
                    this.moveInDirection(action.direction);
                } else if (action.type === 'FEED') {
                    this.feed();
                    this.player.turn++;
                    this.player.age++;
                } else if (action.type === 'MATE') {
                    this.mate();
                    this.player.turn++;
                } else if (action.type === 'SELECT_OFFSPRING') {
                    this.selectOffspring(action.index);
                }
                
                this.agent.reward(this);
                this.updateAllUI();
            }
            
            updateAllUI() {
                document.getElementById('stage-display').textContent = this.player.stage;
                document.getElementById('age-display').textContent = this.player.age;
                document.getElementById('max-age-display').textContent = this.player.maxAge;
                document.getElementById('gen-display').textContent = this.generation;
                document.getElementById('energy-display').textContent = Math.floor(this.player.energy);
                
                const loci = Object.keys(this.player.genome.slots).filter(k => this.player.genome.slots[k]).length;
                document.getElementById('loci-count').textContent = loci;
                document.getElementById('instability-display').textContent = this.player.genome.instability;
                
                const dnaItems = this.player.inventory.length;
                document.getElementById('dna-count').textContent = dnaItems;
                
                document.getElementById('npc-count').textContent = this.npcFlies.length;
                
                const nearFood = this.foodSources.filter(f => {
                    const dist = Math.abs(f.q - this.player.q) + Math.abs(f.r - this.player.r);
                    return dist <= 5 && f.respawnTimer === 0;
                }).length;
                document.getElementById('food-count').textContent = nearFood;
                
                document.getElementById('ai-fitness').textContent = Math.floor(this.agent.currentFitness);
                document.getElementById('ai-strategy').textContent = this.agent.currentStrategy;
                
                // Respawn food
                this.foodSources.forEach(f => {
                    if (f.respawnTimer > 0) {
                        f.respawnTimer--;
                        if (f.respawnTimer === 0) this.drawWorld();
                    }
                });
            }
            
            log(message, color = '#ffff00') {
                console.log(message);
            }
        }
        
        const config = {
            type: Phaser.AUTO,
            width: 900,
            height: 720,
            parent: 'phaser-canvas',
            backgroundColor: '#1a1a1a',
            scene: [GameScene]
        };
        
        const game = new Phaser.Game(config);
    </script>
</body>
</html>
